// TODO: autogenerate from crates/shaders/build.rs
// TODO: minify/compress shaders (get rid of comments?)

// Data temporarily from vello/target/release/build/vello_shaders-333625b1f69e3492/out/shaders.rs
// Will improve in the future

// Shaders and info have the following license:

/*
Copyright (c) 2020 Raph Levien

Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */

const shaders = ( format ) => ( {
  backdrop: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Note: this is the non-atomic version\nstruct Tile {\n    backdrop: i32,\n    segments: u32,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage, read_write> tiles: array<Tile>;\n\nconst WG_SIZE = 64u;\n\nvar<workgroup> sh_backdrop: array<i32, WG_SIZE>;\n\n// Each workgroup computes the inclusive prefix sum of the backdrops\n// in one row of tiles.\n@compute @workgroup_size(64)\nfn main(\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n    let width_in_tiles = config.width_in_tiles;\n    let ix = wg_id.x * width_in_tiles + local_id.x;\n    var backdrop = 0;\n    if local_id.x < width_in_tiles {\n        backdrop = tiles[ix].backdrop;\n    }\n    sh_backdrop[local_id.x] = backdrop;\n    // iterate log2(WG_SIZE) times\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x >= (1u << i) {\n            backdrop += sh_backdrop[local_id.x - (1u << i)];\n        }\n        workgroupBarrier();\n        sh_backdrop[local_id.x] = backdrop;\n    }\n    if local_id.x < width_in_tiles {\n        tiles[ix].backdrop = backdrop;\n    }\n}\n",
    workgroup_size: [ 64, 1, 1 ],
    bindings: [ 'Uniform', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 256, index: 0 }
    ]
  },
  backdrop_dyn: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Prefix sum for dynamically allocated backdrops\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Common datatypes for path and tile intermediate info.\n\nstruct Path {\n    // bounding box in tiles\n    bbox: vec4<u32>,\n    // offset (in u32's) to tile rectangle\n    tiles: u32,\n}\n\nstruct Tile {\n    backdrop: i32,\n    segments: u32,\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> paths: array<Path>;\n\n@group(0) @binding(2)\nvar<storage, read_write> tiles: array<Tile>;\n\nconst WG_SIZE = 256u;\n\nvar<workgroup> sh_row_width: array<u32, WG_SIZE>;\nvar<workgroup> sh_row_count: array<u32, WG_SIZE>;\nvar<workgroup> sh_offset: array<u32, WG_SIZE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n) {\n    let drawobj_ix = global_id.x;\n    var row_count = 0u;\n    if drawobj_ix < config.n_drawobj {\n        // TODO: when rectangles, path and draw obj are not the same\n        let path = paths[drawobj_ix];\n        sh_row_width[local_id.x] = path.bbox.z - path.bbox.x;\n        row_count = path.bbox.w - path.bbox.y;\n        sh_offset[local_id.x] = path.tiles;\n    }\n    sh_row_count[local_id.x] = row_count;\n\n    // Prefix sum of row counts\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x >= (1u << i) {\n            row_count += sh_row_count[local_id.x - (1u << i)];\n        }\n        workgroupBarrier();\n        sh_row_count[local_id.x] = row_count;\n    }\n    workgroupBarrier();\n    let total_rows = sh_row_count[WG_SIZE - 1u];\n    for (var row = local_id.x; row < total_rows; row += WG_SIZE) {\n        var el_ix = 0u;\n        for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n            let probe = el_ix + ((WG_SIZE / 2u) >> i);\n            if row >= sh_row_count[probe - 1u] {\n                el_ix = probe;\n            }\n        }\n        let width = sh_row_width[el_ix];\n        if width > 0u {\n            var seq_ix = row - select(0u, sh_row_count[el_ix - 1u], el_ix > 0u);\n            var tile_ix = sh_offset[el_ix] + seq_ix * width;\n            var sum = tiles[tile_ix].backdrop;\n            for (var x = 1u; x < width; x += 1u) {\n                tile_ix += 1u;\n                sum += tiles[tile_ix].backdrop;\n                tiles[tile_ix].backdrop = sum;\n            }\n        }\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 1024, index: 0 },
      { size_in_bytes: 1024, index: 1 },
      { size_in_bytes: 1024, index: 2 }
    ]
  },
  bbox_clear: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\nstruct PathBbox {\n    x0: i32,\n    y0: i32,\n    x1: i32,\n    y1: i32,\n    linewidth: f32,\n    trans_ix: u32,\n}\n\n@group(0) @binding(1)\nvar<storage, read_write> path_bboxes: array<PathBbox>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n) {\n    let ix = global_id.x;\n    if ix < config.n_path {\n        path_bboxes[ix].x0 = 0x7fffffff;\n        path_bboxes[ix].y0 = 0x7fffffff;\n        path_bboxes[ix].x1 = -0x80000000;\n        path_bboxes[ix].y1 = -0x80000000;\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'Buffer' ],
    workgroup_buffers: []
  },
  binning: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The binning stage\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The DrawMonoid is computed as a prefix sum to aid in decoding\n// the variable-length encoding of draw objects.\nstruct DrawMonoid {\n    // The number of paths preceding this draw object.\n    path_ix: u32,\n    // The number of clip operations preceding this draw object.\n    clip_ix: u32,\n    // The offset of the encoded draw object in the scene (u32s).\n    scene_offset: u32,\n    // The offset of the associated info.\n    info_offset: u32,\n}\n\n// Each draw object has a 32-bit draw tag, which is a bit-packed\n// version of the draw monoid.\nconst DRAWTAG_NOP = 0u;\nconst DRAWTAG_FILL_COLOR = 0x44u;\nconst DRAWTAG_FILL_LIN_GRADIENT = 0x114u;\nconst DRAWTAG_FILL_RAD_GRADIENT = 0x29cu;\nconst DRAWTAG_FILL_IMAGE = 0x248u;\nconst DRAWTAG_BEGIN_CLIP = 0x9u;\nconst DRAWTAG_END_CLIP = 0x21u;\n\nfn draw_monoid_identity() -> DrawMonoid {\n    return DrawMonoid();\n}\n\nfn combine_draw_monoid(a: DrawMonoid, b: DrawMonoid) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = a.path_ix + b.path_ix;\n    c.clip_ix = a.clip_ix + b.clip_ix;\n    c.scene_offset = a.scene_offset + b.scene_offset;\n    c.info_offset = a.info_offset + b.info_offset;\n    return c;\n}\n\nfn map_draw_tag(tag_word: u32) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = u32(tag_word != DRAWTAG_NOP);\n    c.clip_ix = tag_word & 1u;\n    c.scene_offset = (tag_word >> 2u) & 0x07u;\n    c.info_offset = (tag_word >> 6u) & 0x0fu;\n    return c;\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The annotated bounding box for a path. It has been transformed,\n// but contains a link to the active transform, mostly for gradients.\n// Coordinates are integer pixels (for the convenience of atomic update)\n// but will probably become fixed-point fractions for rectangles.\nstruct PathBbox {\n    x0: i32,\n    y0: i32,\n    x1: i32,\n    y1: i32,\n    linewidth: f32,\n    trans_ix: u32,\n}\n\nfn bbox_intersect(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\n    return vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Bitflags for each stage that can fail allocation.\nconst STAGE_BINNING: u32 = 0x1u;\nconst STAGE_TILE_ALLOC: u32 = 0x2u;\nconst STAGE_PATH_COARSE: u32 = 0x4u;\nconst STAGE_COARSE: u32 = 0x8u;\n\n// This must be kept in sync with the struct in src/render.rs\nstruct BumpAllocators {\n    // Bitmask of stages that have failed allocation.\n    failed: atomic<u32>,\n    binning: atomic<u32>,\n    ptcl: atomic<u32>,\n    tile: atomic<u32>,\n    segments: atomic<u32>,\n    blend: atomic<u32>,\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> draw_monoids: array<DrawMonoid>;\n\n@group(0) @binding(2)\nvar<storage> path_bbox_buf: array<PathBbox>;\n\n@group(0) @binding(3)\nvar<storage> clip_bbox_buf: array<vec4<f32>>;\n\n@group(0) @binding(4)\nvar<storage, read_write> intersected_bbox: array<vec4<f32>>;\n\n@group(0) @binding(5)\nvar<storage, read_write> bump: BumpAllocators;\n\n@group(0) @binding(6)\nvar<storage, read_write> bin_data: array<u32>;\n\n// TODO: put in common place\nstruct BinHeader {\n    element_count: u32,\n    chunk_offset: u32,\n}\n\n@group(0) @binding(7)\nvar<storage, read_write> bin_header: array<BinHeader>;\n\n// conversion factors from coordinates to bin\nconst SX = 0.00390625;\nconst SY = 0.00390625;\n//let SX = 1.0 / f32(N_TILE_X * TILE_WIDTH);\n//let SY = 1.0 / f32(N_TILE_Y * TILE_HEIGHT);\n\nconst WG_SIZE = 256u;\nconst N_SLICE = 8u;\n//let N_SLICE = WG_SIZE / 32u;\nconst N_SUBSLICE = 4u;\n\nvar<workgroup> sh_bitmaps: array<array<atomic<u32>, N_TILE>, N_SLICE>;\n// store count values packed two u16's to a u32\nvar<workgroup> sh_count: array<array<u32, N_TILE>, N_SUBSLICE>;\nvar<workgroup> sh_chunk_offset: array<u32, N_TILE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n    for (var i = 0u; i < N_SLICE; i += 1u) {\n        atomicStore(&sh_bitmaps[i][local_id.x], 0u);\n    }\n    workgroupBarrier();\n\n    // Read inputs and determine coverage of bins\n    let element_ix = global_id.x;\n    var x0 = 0;\n    var y0 = 0;\n    var x1 = 0;\n    var y1 = 0;\n    if element_ix < config.n_drawobj {\n        let draw_monoid = draw_monoids[element_ix];\n        var clip_bbox = vec4(-1e9, -1e9, 1e9, 1e9);\n        if draw_monoid.clip_ix > 0u {\n            clip_bbox = clip_bbox_buf[draw_monoid.clip_ix - 1u];\n        }\n        // For clip elements, clip_box is the bbox of the clip path,\n        // intersected with enclosing clips.\n        // For other elements, it is the bbox of the enclosing clips.\n        // TODO check this is true\n\n        let path_bbox = path_bbox_buf[draw_monoid.path_ix];\n        let pb = vec4<f32>(vec4(path_bbox.x0, path_bbox.y0, path_bbox.x1, path_bbox.y1));\n        let bbox_raw = bbox_intersect(clip_bbox, pb);\n        // TODO(naga): clunky expression a workaround for broken lhs swizzle\n        let bbox = vec4(bbox_raw.xy, max(bbox_raw.xy, bbox_raw.zw));\n\n        intersected_bbox[element_ix] = bbox;\n        x0 = i32(floor(bbox.x * SX));\n        y0 = i32(floor(bbox.y * SY));\n        x1 = i32(ceil(bbox.z * SX));\n        y1 = i32(ceil(bbox.w * SY));\n    }\n    let width_in_bins = i32((config.width_in_tiles + N_TILE_X - 1u) / N_TILE_X);\n    let height_in_bins = i32((config.height_in_tiles + N_TILE_Y - 1u) / N_TILE_Y);\n    x0 = clamp(x0, 0, width_in_bins);\n    y0 = clamp(y0, 0, height_in_bins);\n    x1 = clamp(x1, 0, width_in_bins);\n    y1 = clamp(y1, 0, height_in_bins);\n    if x0 == x1 {\n        y1 = y0;\n    }\n    var x = x0;\n    var y = y0;\n    let my_slice = local_id.x / 32u;\n    let my_mask = 1u << (local_id.x & 31u);\n    while y < y1 {\n        atomicOr(&sh_bitmaps[my_slice][y * width_in_bins + x], my_mask);\n        x += 1;\n        if x == x1 {\n            x = x0;\n            y += 1;\n        }\n    }\n\n    workgroupBarrier();\n    // Allocate output segments\n    var element_count = 0u;\n    for (var i = 0u; i < N_SUBSLICE; i += 1u) {\n        element_count += countOneBits(atomicLoad(&sh_bitmaps[i * 2u][local_id.x]));\n        let element_count_lo = element_count;\n        element_count += countOneBits(atomicLoad(&sh_bitmaps[i * 2u + 1u][local_id.x]));\n        let element_count_hi = element_count;\n        let element_count_packed = element_count_lo | (element_count_hi << 16u);\n        sh_count[i][local_id.x] = element_count_packed;\n    }\n    // element_count is the number of draw objects covering this thread's bin\n    var chunk_offset = atomicAdd(&bump.binning, element_count);\n    if chunk_offset + element_count > config.binning_size {\n        chunk_offset = 0u;\n        atomicOr(&bump.failed, STAGE_BINNING);\n    }    \n    sh_chunk_offset[local_id.x] = chunk_offset;\n    bin_header[global_id.x].element_count = element_count;\n    bin_header[global_id.x].chunk_offset = chunk_offset;\n    workgroupBarrier();\n\n    // loop over bbox of bins touched by this draw object\n    x = x0;\n    y = y0;\n    while y < y1 {\n        let bin_ix = y * width_in_bins + x;\n        let out_mask = atomicLoad(&sh_bitmaps[my_slice][bin_ix]);\n        // I think this predicate will always be true...\n        if (out_mask & my_mask) != 0u {\n            var idx = countOneBits(out_mask & (my_mask - 1u));\n            if my_slice > 0u {\n                let count_ix = my_slice - 1u;\n                let count_packed = sh_count[count_ix / 2u][bin_ix];\n                idx += (count_packed >> (16u * (count_ix & 1u))) & 0xffffu;\n            }\n            let offset = config.bin_data_start + sh_chunk_offset[bin_ix];\n            bin_data[offset + idx] = element_ix;\n        }\n        x += 1;\n        if x == x1 {\n            x = x0;\n            y += 1;\n        }\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer', 'Buffer', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 8192, index: 0 },
      { size_in_bytes: 4096, index: 1 },
      { size_in_bytes: 1024, index: 2 }
    ]
  },
  clip_leaf: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The annotated bounding box for a path. It has been transformed,\n// but contains a link to the active transform, mostly for gradients.\n// Coordinates are integer pixels (for the convenience of atomic update)\n// but will probably become fixed-point fractions for rectangles.\nstruct PathBbox {\n    x0: i32,\n    y0: i32,\n    x1: i32,\n    y1: i32,\n    linewidth: f32,\n    trans_ix: u32,\n}\n\nfn bbox_intersect(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\n    return vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n \nstruct Bic {\n    a: u32,\n    b: u32,\n}\n\nfn bic_combine(x: Bic, y: Bic) -> Bic {\n    let m = min(x.b, y.a);\n    return Bic(x.a + y.a - m, x.b + y.b - m);\n}\n\nstruct ClipInp {\n    // Index of the draw object.\n    ix: u32,\n    // This is a packed encoding of an enum with the sign bit as the tag. If positive,\n    // this entry is a BeginClip and contains the associated path index. If negative,\n    // it is an EndClip and contains the bitwise-not of the EndClip draw object index.\n    path_ix: i32,\n}\n\nstruct ClipEl {\n    parent_ix: u32,\n    bbox: vec4<f32>,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The DrawMonoid is computed as a prefix sum to aid in decoding\n// the variable-length encoding of draw objects.\nstruct DrawMonoid {\n    // The number of paths preceding this draw object.\n    path_ix: u32,\n    // The number of clip operations preceding this draw object.\n    clip_ix: u32,\n    // The offset of the encoded draw object in the scene (u32s).\n    scene_offset: u32,\n    // The offset of the associated info.\n    info_offset: u32,\n}\n\n// Each draw object has a 32-bit draw tag, which is a bit-packed\n// version of the draw monoid.\nconst DRAWTAG_NOP = 0u;\nconst DRAWTAG_FILL_COLOR = 0x44u;\nconst DRAWTAG_FILL_LIN_GRADIENT = 0x114u;\nconst DRAWTAG_FILL_RAD_GRADIENT = 0x29cu;\nconst DRAWTAG_FILL_IMAGE = 0x248u;\nconst DRAWTAG_BEGIN_CLIP = 0x9u;\nconst DRAWTAG_END_CLIP = 0x21u;\n\nfn draw_monoid_identity() -> DrawMonoid {\n    return DrawMonoid();\n}\n\nfn combine_draw_monoid(a: DrawMonoid, b: DrawMonoid) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = a.path_ix + b.path_ix;\n    c.clip_ix = a.clip_ix + b.clip_ix;\n    c.scene_offset = a.scene_offset + b.scene_offset;\n    c.info_offset = a.info_offset + b.info_offset;\n    return c;\n}\n\nfn map_draw_tag(tag_word: u32) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = u32(tag_word != DRAWTAG_NOP);\n    c.clip_ix = tag_word & 1u;\n    c.scene_offset = (tag_word >> 2u) & 0x07u;\n    c.info_offset = (tag_word >> 6u) & 0x0fu;\n    return c;\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> clip_inp: array<ClipInp>;\n\n@group(0) @binding(2)\nvar<storage> path_bboxes: array<PathBbox>;\n\n@group(0) @binding(3)\nvar<storage> reduced: array<Bic>;\n\n@group(0) @binding(4)\nvar<storage> clip_els: array<ClipEl>;\n\n@group(0) @binding(5)\nvar<storage, read_write> draw_monoids: array<DrawMonoid>;\n\n@group(0) @binding(6)\nvar<storage, read_write> clip_bboxes: array<vec4<f32>>;\n\nconst WG_SIZE = 256u;\nvar<workgroup> sh_bic: array<Bic, 510 >;\nvar<workgroup> sh_stack: array<u32, WG_SIZE>;\nvar<workgroup> sh_stack_bbox: array<vec4<f32>, WG_SIZE>;\nvar<workgroup> sh_bbox: array<vec4<f32>, WG_SIZE>;\nvar<workgroup> sh_link: array<i32, WG_SIZE>;\n\nfn search_link(bic: ptr<function, Bic>, ix_in: u32) -> i32 {\n    var ix = ix_in;\n    var j = 0u;\n    while j < firstTrailingBit(WG_SIZE) {\n        let base = 2u * WG_SIZE - (2u << (firstTrailingBit(WG_SIZE) - j));\n        if ((ix >> j) & 1u) != 0u {\n            let test = bic_combine(sh_bic[base + (ix >> j) - 1u], *bic);\n            if test.b > 0u {\n                break;\n            }\n            *bic = test;\n            ix -= 1u << j;\n        }\n        j += 1u;\n    }\n    if ix > 0u {\n        while j > 0u {\n            j -= 1u;\n            let base = 2u * WG_SIZE - (2u << (firstTrailingBit(WG_SIZE) - j));\n            let test = bic_combine(sh_bic[base + (ix >> j) - 1u], *bic);\n            if test.b == 0u {\n                *bic = test;\n                ix -= 1u << j;\n            }\n        }\n    }\n    if ix > 0u {\n        return i32(ix) - 1;\n    } else {\n        return i32(~0u - (*bic).a);\n    }\n}\n\nfn load_clip_path(ix: u32) -> i32 {\n    if ix < config.n_clip {\n        return clip_inp[ix].path_ix;\n    } else {\n        return -2147483648;\n        // literal too large?\n        // return 0x80000000;\n    }\n}\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n    var bic: Bic;\n    if local_id.x < wg_id.x {\n        bic = reduced[local_id.x];\n    }\n    sh_bic[local_id.x] = bic;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x + (1u << i) < WG_SIZE {\n            let other = sh_bic[local_id.x + (1u << i)];\n            bic = bic_combine(bic, other);\n        }\n        workgroupBarrier();\n        sh_bic[local_id.x] = bic;\n    }\n    workgroupBarrier();\n    let stack_size = sh_bic[0].b;\n    // TODO: if stack depth > WG_SIZE desired, scan here\n\n    // binary search in stack\n    let sp = WG_SIZE - 1u - local_id.x;\n    var ix = 0u;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        let probe = ix + ((WG_SIZE / 2u) >> i);\n        if sp < sh_bic[probe].b {\n            ix = probe;\n        }\n    }\n    let b = sh_bic[ix].b;\n    var bbox = vec4(-1e9, -1e9, 1e9, 1e9);\n    if sp < b {\n        let el = clip_els[ix * WG_SIZE + b - sp - 1u];\n        sh_stack[local_id.x] = el.parent_ix;\n        bbox = el.bbox;\n    }\n    // forward scan of bbox values of prefix stack\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        sh_stack_bbox[local_id.x] = bbox;\n        workgroupBarrier();\n        if local_id.x >= (1u << i) {\n            bbox = bbox_intersect(sh_stack_bbox[local_id.x - (1u << i)], bbox);\n        }\n        workgroupBarrier();\n    }\n    sh_stack_bbox[local_id.x] = bbox;\n\n    // Read input and compute Bic binary tree\n    let inp = load_clip_path(global_id.x);\n    let is_push = inp >= 0;\n    bic = Bic(1u - u32(is_push), u32(is_push));\n    sh_bic[local_id.x] = bic;\n    if is_push {\n        let path_bbox = path_bboxes[inp];\n        bbox = vec4(f32(path_bbox.x0), f32(path_bbox.y0), f32(path_bbox.x1), f32(path_bbox.y1));\n    } else {\n        bbox = vec4(-1e9, -1e9, 1e9, 1e9);\n    }\n    var inbase = 0u;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE) - 1u; i += 1u) {\n        let outbase = 2u * WG_SIZE - (1u << (firstTrailingBit(WG_SIZE) - i));\n        workgroupBarrier();\n        if local_id.x < 1u << (firstTrailingBit(WG_SIZE) - 1u - i) {\n            let in_off = inbase + local_id.x * 2u;\n            sh_bic[outbase + local_id.x] = bic_combine(sh_bic[in_off], sh_bic[in_off + 1u]);\n        }\n        inbase = outbase;\n    }\n    workgroupBarrier();\n    // search for predecessor node\n    bic = Bic();\n    var link = search_link(&bic, local_id.x);\n    sh_link[local_id.x] = link;\n    workgroupBarrier();\n    let grandparent = select(link - 1, sh_link[link], link >= 0);\n    var parent: i32;\n    if link >= 0 {\n        parent = i32(wg_id.x * WG_SIZE) + link;\n    } else if link + i32(stack_size) >= 0 {\n        parent = i32(sh_stack[i32(WG_SIZE) + link]);\n    } else {\n        parent = -1;\n    }\n    // bbox scan (intersect) across parent links\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        if i != 0u {\n            sh_link[local_id.x] = link;\n        }\n        sh_bbox[local_id.x] = bbox;\n        workgroupBarrier();\n        if link >= 0 {\n            bbox = bbox_intersect(sh_bbox[link], bbox);\n            link = sh_link[link];\n        }\n        workgroupBarrier();\n    }\n    if link + i32(stack_size) >= 0 {\n        bbox = bbox_intersect(sh_stack_bbox[i32(WG_SIZE) + link], bbox);\n    }\n    // At this point, bbox is the intersection of bboxes on the path to the root\n    sh_bbox[local_id.x] = bbox;\n    workgroupBarrier();\n\n    if !is_push && global_id.x < config.n_clip {\n        // Fix up drawmonoid so path_ix of EndClip matches BeginClip\n        let parent_clip = clip_inp[parent];\n        let path_ix = parent_clip.path_ix;\n        let parent_ix = parent_clip.ix;\n        let ix = ~inp;\n        draw_monoids[ix].path_ix = u32(path_ix);\n        // Make EndClip point to the same draw data as BeginClip\n        draw_monoids[ix].scene_offset = draw_monoids[parent_ix].scene_offset;\n        if grandparent >= 0 {\n            bbox = sh_bbox[grandparent];\n        } else if grandparent + i32(stack_size) >= 0 {\n            bbox = sh_stack_bbox[i32(WG_SIZE) + grandparent];\n        } else {\n            bbox = vec4(-1e9, -1e9, 1e9, 1e9);\n        }\n    }\n    if global_id.x < config.n_clip {\n        clip_bboxes[global_id.x] = bbox;\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 4080, index: 0 },
      { size_in_bytes: 1024, index: 1 },
      { size_in_bytes: 4096, index: 2 },
      { size_in_bytes: 4096, index: 3 },
      { size_in_bytes: 1024, index: 4 }
    ]
  },
  clip_reduce: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The annotated bounding box for a path. It has been transformed,\n// but contains a link to the active transform, mostly for gradients.\n// Coordinates are integer pixels (for the convenience of atomic update)\n// but will probably become fixed-point fractions for rectangles.\nstruct PathBbox {\n    x0: i32,\n    y0: i32,\n    x1: i32,\n    y1: i32,\n    linewidth: f32,\n    trans_ix: u32,\n}\n\nfn bbox_intersect(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\n    return vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n \nstruct Bic {\n    a: u32,\n    b: u32,\n}\n\nfn bic_combine(x: Bic, y: Bic) -> Bic {\n    let m = min(x.b, y.a);\n    return Bic(x.a + y.a - m, x.b + y.b - m);\n}\n\nstruct ClipInp {\n    // Index of the draw object.\n    ix: u32,\n    // This is a packed encoding of an enum with the sign bit as the tag. If positive,\n    // this entry is a BeginClip and contains the associated path index. If negative,\n    // it is an EndClip and contains the bitwise-not of the EndClip draw object index.\n    path_ix: i32,\n}\n\nstruct ClipEl {\n    parent_ix: u32,\n    bbox: vec4<f32>,\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> clip_inp: array<ClipInp>;\n\n@group(0) @binding(2)\nvar<storage> path_bboxes: array<PathBbox>;\n\n@group(0) @binding(3)\nvar<storage, read_write> reduced: array<Bic>;\n\n@group(0) @binding(4)\nvar<storage, read_write> clip_out: array<ClipEl>;\n\nconst WG_SIZE = 256u;\nvar<workgroup> sh_bic: array<Bic, WG_SIZE>;\nvar<workgroup> sh_parent: array<u32, WG_SIZE>;\nvar<workgroup> sh_path_ix: array<u32, WG_SIZE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n    let inp = clip_inp[global_id.x].path_ix;\n    let is_push = inp >= 0;\n    var bic = Bic(1u - u32(is_push), u32(is_push));\n    // reverse scan of bicyclic semigroup\n    sh_bic[local_id.x] = bic;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x + (1u << i) < WG_SIZE {\n            let other = sh_bic[local_id.x + (1u << i)];\n            bic = bic_combine(bic, other);\n        }\n        workgroupBarrier();\n        sh_bic[local_id.x] = bic;\n    }\n    if local_id.x == 0u {\n        reduced[wg_id.x] = bic;\n    }\n    workgroupBarrier();\n    let size = sh_bic[0].b;\n    bic = Bic();\n    if is_push && bic.a == 0u {\n        let local_ix = size - bic.b - 1u;\n        sh_parent[local_ix] = local_id.x;\n        sh_path_ix[local_ix] = u32(inp);\n    }\n    workgroupBarrier();\n    // TODO: possibly do forward scan here if depth can exceed wg size\n    if local_id.x < size {\n        let path_ix = sh_path_ix[local_id.x];\n        let path_bbox = path_bboxes[path_ix];\n        let parent_ix = sh_parent[local_id.x] + wg_id.x * WG_SIZE;\n        let bbox = vec4(f32(path_bbox.x0), f32(path_bbox.y0), f32(path_bbox.x1), f32(path_bbox.y1));\n        clip_out[global_id.x] = ClipEl(parent_ix, bbox);\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    // TODO: ShaderInfo had bindings: [ 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
    // TODO: shaders.rs has         &[
    //         BindType::Uniform,
    //         BindType::BufReadOnly,
    //         BindType::BufReadOnly,
    //         BindType::Buffer,
    //         BindType::Buffer,
    //     ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 2048, index: 0 },
      { size_in_bytes: 1024, index: 1 },
      { size_in_bytes: 1024, index: 2 }
    ]
  },
  coarse: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The coarse rasterization stage.\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Bitflags for each stage that can fail allocation.\nconst STAGE_BINNING: u32 = 0x1u;\nconst STAGE_TILE_ALLOC: u32 = 0x2u;\nconst STAGE_PATH_COARSE: u32 = 0x4u;\nconst STAGE_COARSE: u32 = 0x8u;\n\n// This must be kept in sync with the struct in src/render.rs\nstruct BumpAllocators {\n    // Bitmask of stages that have failed allocation.\n    failed: atomic<u32>,\n    binning: atomic<u32>,\n    ptcl: atomic<u32>,\n    tile: atomic<u32>,\n    segments: atomic<u32>,\n    blend: atomic<u32>,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The DrawMonoid is computed as a prefix sum to aid in decoding\n// the variable-length encoding of draw objects.\nstruct DrawMonoid {\n    // The number of paths preceding this draw object.\n    path_ix: u32,\n    // The number of clip operations preceding this draw object.\n    clip_ix: u32,\n    // The offset of the encoded draw object in the scene (u32s).\n    scene_offset: u32,\n    // The offset of the associated info.\n    info_offset: u32,\n}\n\n// Each draw object has a 32-bit draw tag, which is a bit-packed\n// version of the draw monoid.\nconst DRAWTAG_NOP = 0u;\nconst DRAWTAG_FILL_COLOR = 0x44u;\nconst DRAWTAG_FILL_LIN_GRADIENT = 0x114u;\nconst DRAWTAG_FILL_RAD_GRADIENT = 0x29cu;\nconst DRAWTAG_FILL_IMAGE = 0x248u;\nconst DRAWTAG_BEGIN_CLIP = 0x9u;\nconst DRAWTAG_END_CLIP = 0x21u;\n\nfn draw_monoid_identity() -> DrawMonoid {\n    return DrawMonoid();\n}\n\nfn combine_draw_monoid(a: DrawMonoid, b: DrawMonoid) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = a.path_ix + b.path_ix;\n    c.clip_ix = a.clip_ix + b.clip_ix;\n    c.scene_offset = a.scene_offset + b.scene_offset;\n    c.info_offset = a.info_offset + b.info_offset;\n    return c;\n}\n\nfn map_draw_tag(tag_word: u32) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = u32(tag_word != DRAWTAG_NOP);\n    c.clip_ix = tag_word & 1u;\n    c.scene_offset = (tag_word >> 2u) & 0x07u;\n    c.info_offset = (tag_word >> 6u) & 0x0fu;\n    return c;\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Layout of per-tile command list\n// Initial allocation, in u32's.\nconst PTCL_INITIAL_ALLOC = 64u;\nconst PTCL_INCREMENT = 256u;\n\n// Amount of space taken by jump\nconst PTCL_HEADROOM = 2u;\n\n// Tags for PTCL commands\nconst CMD_END = 0u;\nconst CMD_FILL = 1u;\nconst CMD_STROKE = 2u;\nconst CMD_SOLID = 3u;\nconst CMD_COLOR = 5u;\nconst CMD_LIN_GRAD = 6u;\nconst CMD_RAD_GRAD = 7u;\nconst CMD_IMAGE = 8u;\nconst CMD_BEGIN_CLIP = 9u;\nconst CMD_END_CLIP = 10u;\nconst CMD_JUMP = 11u;\n\n// The individual PTCL structs are written here, but read/write is by\n// hand in the relevant shaders\n\nstruct CmdFill {\n    tile: u32,\n    backdrop: i32,\n}\n\nstruct CmdStroke {\n    tile: u32,\n    half_width: f32,\n}\n\nstruct CmdJump {\n    new_ix: u32,\n}\n\nstruct CmdColor {\n    rgba_color: u32,\n}\n\nstruct CmdLinGrad {\n    index: u32,\n    extend_mode: u32,\n    line_x: f32,\n    line_y: f32,\n    line_c: f32,\n}\n\nstruct CmdRadGrad {\n    index: u32,\n    extend_mode: u32,\n    matrx: vec4<f32>,\n    xlat: vec2<f32>,\n    focal_x: f32,\n    radius: f32,\n    kind: u32,\n    flags: u32,\n}\n\nstruct CmdImage {\n    matrx: vec4<f32>,\n    xlat: vec2<f32>,\n    atlas_offset: vec2<f32>,\n    extents: vec2<f32>,\n}\n\nstruct CmdEndClip {\n    blend: u32,\n    alpha: f32,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Common datatypes for path and tile intermediate info.\n\nstruct Path {\n    // bounding box in tiles\n    bbox: vec4<u32>,\n    // offset (in u32's) to tile rectangle\n    tiles: u32,\n}\n\nstruct Tile {\n    backdrop: i32,\n    segments: u32,\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage> draw_monoids: array<DrawMonoid>;\n\n// TODO: dedup\nstruct BinHeader {\n    element_count: u32,\n    chunk_offset: u32,\n}\n\n@group(0) @binding(3)\nvar<storage> bin_headers: array<BinHeader>;\n\n@group(0) @binding(4)\nvar<storage> info_bin_data: array<u32>;\n\n@group(0) @binding(5)\nvar<storage> paths: array<Path>;\n\n@group(0) @binding(6)\nvar<storage> tiles: array<Tile>;\n\n@group(0) @binding(7)\nvar<storage, read_write> bump: BumpAllocators;\n\n@group(0) @binding(8)\nvar<storage, read_write> ptcl: array<u32>;\n\n\n\n// Much of this code assumes WG_SIZE == N_TILE. If these diverge, then\n// a fair amount of fixup is needed.\nconst WG_SIZE = 256u;\n//let N_SLICE = WG_SIZE / 32u;\nconst N_SLICE = 8u;\n\nvar<workgroup> sh_bitmaps: array<array<atomic<u32>, N_TILE>, N_SLICE>;\nvar<workgroup> sh_part_count: array<u32, WG_SIZE>;\nvar<workgroup> sh_part_offsets: array<u32, WG_SIZE>;\nvar<workgroup> sh_drawobj_ix: array<u32, WG_SIZE>;\nvar<workgroup> sh_tile_stride: array<u32, WG_SIZE>;\nvar<workgroup> sh_tile_width: array<u32, WG_SIZE>;\nvar<workgroup> sh_tile_x0y0: array<u32, WG_SIZE>;\nvar<workgroup> sh_tile_count: array<u32, WG_SIZE>;\nvar<workgroup> sh_tile_base: array<u32, WG_SIZE>;\n\n// helper functions for writing ptcl\n\nvar<private> cmd_offset: u32;\nvar<private> cmd_limit: u32;\n\n// Make sure there is space for a command of given size, plus a jump if needed\nfn alloc_cmd(size: u32) {\n    if cmd_offset + size >= cmd_limit {\n        // We might be able to save a little bit of computation here\n        // by setting the initial value of the bump allocator.\n        let ptcl_dyn_start = config.width_in_tiles * config.height_in_tiles * PTCL_INITIAL_ALLOC;\n        var new_cmd = ptcl_dyn_start + atomicAdd(&bump.ptcl, PTCL_INCREMENT);\n        if new_cmd + PTCL_INCREMENT > config.ptcl_size {\n            new_cmd = 0u;\n            atomicOr(&bump.failed, STAGE_COARSE);\n        }\n        ptcl[cmd_offset] = CMD_JUMP;\n        ptcl[cmd_offset + 1u] = new_cmd;\n        cmd_offset = new_cmd;\n        cmd_limit = cmd_offset + (PTCL_INCREMENT - PTCL_HEADROOM);\n    }\n}\n\nfn write_path(tile: Tile, linewidth: f32) -> bool {\n    // TODO: take flags\n    alloc_cmd(3u);\n    if linewidth < 0.0 {\n        let even_odd = linewidth < -1.0;\n        if tile.segments != 0u {\n            let fill = CmdFill(tile.segments, tile.backdrop);\n            ptcl[cmd_offset] = CMD_FILL;\n            let segments_and_rule = select(fill.tile << 1u, (fill.tile << 1u) | 1u, even_odd);\n            ptcl[cmd_offset + 1u] = segments_and_rule;\n            ptcl[cmd_offset + 2u] = u32(fill.backdrop);\n            cmd_offset += 3u;\n        } else {\n            if even_odd && (abs(tile.backdrop) & 1) == 0 {\n                return false;\n            }\n            ptcl[cmd_offset] = CMD_SOLID;\n            cmd_offset += 1u;\n        }\n    } else {\n        let stroke = CmdStroke(tile.segments, 0.5 * linewidth);\n        ptcl[cmd_offset] = CMD_STROKE;\n        ptcl[cmd_offset + 1u] = stroke.tile;\n        ptcl[cmd_offset + 2u] = bitcast<u32>(stroke.half_width);\n        cmd_offset += 3u;\n    }\n    return true;\n}\n\nfn write_color(color: CmdColor) {\n    alloc_cmd(2u);\n    ptcl[cmd_offset] = CMD_COLOR;\n    ptcl[cmd_offset + 1u] = color.rgba_color;\n    cmd_offset += 2u;\n}\n\nfn write_grad(ty: u32, index: u32, info_offset: u32) {\n    alloc_cmd(3u);\n    ptcl[cmd_offset] = ty;\n    ptcl[cmd_offset + 1u] = index;\n    ptcl[cmd_offset + 2u] = info_offset;\n    cmd_offset += 3u;\n}\n\nfn write_image(info_offset: u32) {\n    alloc_cmd(2u);\n    ptcl[cmd_offset] = CMD_IMAGE;\n    ptcl[cmd_offset + 1u] = info_offset;\n    cmd_offset += 2u;\n}\n\nfn write_begin_clip() {\n    alloc_cmd(1u);\n    ptcl[cmd_offset] = CMD_BEGIN_CLIP;\n    cmd_offset += 1u;\n}\n\nfn write_end_clip(end_clip: CmdEndClip) {\n    alloc_cmd(3u);\n    ptcl[cmd_offset] = CMD_END_CLIP;\n    ptcl[cmd_offset + 1u] = end_clip.blend;\n    ptcl[cmd_offset + 2u] = bitcast<u32>(end_clip.alpha);\n    cmd_offset += 3u;\n}\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n    // Exit early if prior stages failed, as we can't run this stage.\n    // We need to check only prior stages, as if this stage has failed in another workgroup, \n    // we still want to know this workgroup's memory requirement.   \n    let failed = atomicLoad(&bump.failed);\n    if (failed & (STAGE_BINNING | STAGE_TILE_ALLOC | STAGE_PATH_COARSE)) != 0u {\n        return;\n    }\n    let width_in_bins = (config.width_in_tiles + N_TILE_X - 1u) / N_TILE_X;\n    let bin_ix = width_in_bins * wg_id.y + wg_id.x;\n    let n_partitions = (config.n_drawobj + N_TILE - 1u) / N_TILE;\n\n    // Coordinates of the top left of this bin, in tiles.\n    let bin_tile_x = N_TILE_X * wg_id.x;\n    let bin_tile_y = N_TILE_Y * wg_id.y;\n\n    let tile_x = local_id.x % N_TILE_X;\n    let tile_y = local_id.x / N_TILE_X;\n    let this_tile_ix = (bin_tile_y + tile_y) * config.width_in_tiles + bin_tile_x + tile_x;\n    cmd_offset = this_tile_ix * PTCL_INITIAL_ALLOC;\n    cmd_limit = cmd_offset + (PTCL_INITIAL_ALLOC - PTCL_HEADROOM);\n\n    // clip state\n    var clip_zero_depth = 0u;\n    var clip_depth = 0u;\n\n    var partition_ix = 0u;\n    var rd_ix = 0u;\n    var wr_ix = 0u;\n    var part_start_ix = 0u;\n    var ready_ix = 0u;\n\n    // blend state\n    var render_blend_depth = 0u;\n    var max_blend_depth = 0u;\n\n    let blend_offset = cmd_offset;\n    cmd_offset += 1u;\n\n    while true {\n        for (var i = 0u; i < N_SLICE; i += 1u) {\n            atomicStore(&sh_bitmaps[i][local_id.x], 0u);\n        }\n\n        while true {\n            if ready_ix == wr_ix && partition_ix < n_partitions {\n                part_start_ix = ready_ix;\n                var count = 0u;\n                if partition_ix + local_id.x < n_partitions {\n                    let in_ix = (partition_ix + local_id.x) * N_TILE + bin_ix;\n                    let bin_header = bin_headers[in_ix];\n                    count = bin_header.element_count;\n                    sh_part_offsets[local_id.x] = bin_header.chunk_offset;\n                }\n                // prefix sum the element counts\n                for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n                    sh_part_count[local_id.x] = count;\n                    workgroupBarrier();\n                    if local_id.x >= (1u << i) {\n                        count += sh_part_count[local_id.x - (1u << i)];\n                    }\n                    workgroupBarrier();\n                }\n                sh_part_count[local_id.x] = part_start_ix + count;\n                workgroupBarrier();\n                ready_ix = sh_part_count[WG_SIZE - 1u];\n                partition_ix += WG_SIZE;\n            }\n            // use binary search to find draw object to read\n            var ix = rd_ix + local_id.x;\n            if ix >= wr_ix && ix < ready_ix {\n                var part_ix = 0u;\n                for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n                    let probe = part_ix + ((N_TILE / 2u) >> i);\n                    if ix >= sh_part_count[probe - 1u] {\n                        part_ix = probe;\n                    }\n                }\n                ix -= select(part_start_ix, sh_part_count[part_ix - 1u], part_ix > 0u);\n                let offset = config.bin_data_start + sh_part_offsets[part_ix];\n                sh_drawobj_ix[local_id.x] = info_bin_data[offset + ix];\n            }\n            wr_ix = min(rd_ix + N_TILE, ready_ix);\n            if wr_ix - rd_ix >= N_TILE || (wr_ix >= ready_ix && partition_ix >= n_partitions) {\n                break;\n            }\n        }\n        // At this point, sh_drawobj_ix[0.. wr_ix - rd_ix] contains merged binning results.\n        var tag = DRAWTAG_NOP;\n        var drawobj_ix: u32;\n        if local_id.x + rd_ix < wr_ix {\n            drawobj_ix = sh_drawobj_ix[local_id.x];\n            tag = scene[config.drawtag_base + drawobj_ix];\n        }\n\n        var tile_count = 0u;\n        // I think this predicate is the same as the last, maybe they can be combined\n        if tag != DRAWTAG_NOP {\n            let path_ix = draw_monoids[drawobj_ix].path_ix;\n            let path = paths[path_ix];\n            let stride = path.bbox.z - path.bbox.x;\n            sh_tile_stride[local_id.x] = stride;\n            let dx = i32(path.bbox.x) - i32(bin_tile_x);\n            let dy = i32(path.bbox.y) - i32(bin_tile_y);\n            let x0 = clamp(dx, 0, i32(N_TILE_X));\n            let y0 = clamp(dy, 0, i32(N_TILE_Y));\n            let x1 = clamp(i32(path.bbox.z) - i32(bin_tile_x), 0, i32(N_TILE_X));\n            let y1 = clamp(i32(path.bbox.w) - i32(bin_tile_y), 0, i32(N_TILE_Y));\n            sh_tile_width[local_id.x] = u32(x1 - x0);\n            sh_tile_x0y0[local_id.x] = u32(x0) | u32(y0 << 16u);\n            tile_count = u32(x1 - x0) * u32(y1 - y0);\n            // base relative to bin\n            let base = path.tiles - u32(dy * i32(stride) + dx);\n            sh_tile_base[local_id.x] = base;\n            // TODO: there's a write_tile_alloc here in the source, not sure what it's supposed to do\n        }\n\n        // Prefix sum of tile counts\n        sh_tile_count[local_id.x] = tile_count;\n        for (var i = 0u; i < firstTrailingBit(N_TILE); i += 1u) {\n            workgroupBarrier();\n            if local_id.x >= (1u << i) {\n                tile_count += sh_tile_count[local_id.x - (1u << i)];\n            }\n            workgroupBarrier();\n            sh_tile_count[local_id.x] = tile_count;\n        }\n        workgroupBarrier();\n        let total_tile_count = sh_tile_count[N_TILE - 1u];\n        // Parallel iteration over all tiles\n        for (var ix = local_id.x; ix < total_tile_count; ix += N_TILE) {\n            // Binary search to find draw object which contains this tile\n            var el_ix = 0u;\n            for (var i = 0u; i < firstTrailingBit(N_TILE); i += 1u) {\n                let probe = el_ix + ((N_TILE / 2u) >> i);\n                if ix >= sh_tile_count[probe - 1u] {\n                    el_ix = probe;\n                }\n            }\n            drawobj_ix = sh_drawobj_ix[el_ix];\n            tag = scene[config.drawtag_base + drawobj_ix];\n            let seq_ix = ix - select(0u, sh_tile_count[el_ix - 1u], el_ix > 0u);\n            let width = sh_tile_width[el_ix];\n            let x0y0 = sh_tile_x0y0[el_ix];\n            let x = (x0y0 & 0xffffu) + seq_ix % width;\n            let y = (x0y0 >> 16u) + seq_ix / width;\n            let tile_ix = sh_tile_base[el_ix] + sh_tile_stride[el_ix] * y + x;\n            let tile = tiles[tile_ix];\n            let is_clip = (tag & 1u) != 0u;\n            var is_blend = false;\n            if is_clip {\n                let BLEND_CLIP = (128u << 8u) | 3u;\n                let scene_offset = draw_monoids[drawobj_ix].scene_offset;\n                let dd = config.drawdata_base + scene_offset;\n                let blend = scene[dd];\n                is_blend = blend != BLEND_CLIP;\n            }\n            let include_tile = tile.segments != 0u || (tile.backdrop == 0) == is_clip || is_blend;\n            if include_tile {\n                let el_slice = el_ix / 32u;\n                let el_mask = 1u << (el_ix & 31u);\n                atomicOr(&sh_bitmaps[el_slice][y * N_TILE_X + x], el_mask);\n            }\n        }\n        workgroupBarrier();\n        // At this point bit drawobj % 32 is set in sh_bitmaps[drawobj / 32][y * N_TILE_X + x]\n        // if drawobj touches tile (x, y).\n\n        // Write per-tile command list for this tile\n        var slice_ix = 0u;\n        var bitmap = atomicLoad(&sh_bitmaps[0u][local_id.x]);\n        while true {\n            if bitmap == 0u {\n                slice_ix += 1u;\n                // potential optimization: make iteration limit dynamic\n                if slice_ix == N_SLICE {\n                    break;\n                }\n                bitmap = atomicLoad(&sh_bitmaps[slice_ix][local_id.x]);\n                if bitmap == 0u {\n                    continue;\n                }\n            }\n            let el_ix = slice_ix * 32u + firstTrailingBit(bitmap);\n            drawobj_ix = sh_drawobj_ix[el_ix];\n            // clear LSB of bitmap, using bit magic\n            bitmap &= bitmap - 1u;\n            let drawtag = scene[config.drawtag_base + drawobj_ix];\n            let dm = draw_monoids[drawobj_ix];\n            let dd = config.drawdata_base + dm.scene_offset;\n            let di = dm.info_offset;\n            if clip_zero_depth == 0u {\n                let tile_ix = sh_tile_base[el_ix] + sh_tile_stride[el_ix] * tile_y + tile_x;\n                let tile = tiles[tile_ix];\n                switch drawtag {\n                    // DRAWTAG_FILL_COLOR\n                    case 0x44u: {\n                        let linewidth = bitcast<f32>(info_bin_data[di]);\n                        if write_path(tile, linewidth) {\n                            let rgba_color = scene[dd];\n                            write_color(CmdColor(rgba_color));\n                        }\n                    }\n                    // DRAWTAG_FILL_LIN_GRADIENT\n                    case 0x114u: {\n                        let linewidth = bitcast<f32>(info_bin_data[di]);\n                        if write_path(tile, linewidth) {\n                            let index = scene[dd];\n                            let info_offset = di + 1u;\n                            write_grad(CMD_LIN_GRAD, index, info_offset);\n                        }\n                    }\n                    // DRAWTAG_FILL_RAD_GRADIENT\n                    case 0x29cu: {\n                        let linewidth = bitcast<f32>(info_bin_data[di]);\n                        if write_path(tile, linewidth) {\n                            let index = scene[dd];\n                            let info_offset = di + 1u;\n                            write_grad(CMD_RAD_GRAD, index, info_offset);\n                        }\n                    }\n                    // DRAWTAG_FILL_IMAGE\n                    case 0x248u: {\n                        let linewidth = bitcast<f32>(info_bin_data[di]);\n                        if write_path(tile, linewidth) {                            \n                            write_image(di + 1u);\n                        }\n                    }\n                    // DRAWTAG_BEGIN_CLIP\n                    case 0x9u: {\n                        if tile.segments == 0u && tile.backdrop == 0 {\n                            clip_zero_depth = clip_depth + 1u;\n                        } else {\n                            write_begin_clip();\n                            render_blend_depth += 1u;\n                            max_blend_depth = max(max_blend_depth, render_blend_depth);\n                        }\n                        clip_depth += 1u;\n                    }\n                    // DRAWTAG_END_CLIP\n                    case 0x21u: {\n                        clip_depth -= 1u;\n                        write_path(tile, -1.0);\n                        let blend = scene[dd];\n                        let alpha = bitcast<f32>(scene[dd + 1u]);\n                        write_end_clip(CmdEndClip(blend, alpha));\n                        render_blend_depth -= 1u;\n                    }\n                    default: {}\n                }\n            } else {\n                // In \"clip zero\" state, suppress all drawing\n                switch drawtag {\n                    // DRAWTAG_BEGIN_CLIP\n                    case 0x9u: {\n                        clip_depth += 1u;\n                    }\n                    // DRAWTAG_END_CLIP\n                    case 0x21u: {\n                        if clip_depth == clip_zero_depth {\n                            clip_zero_depth = 0u;\n                        }\n                        clip_depth -= 1u;\n                    }\n                    default: {}\n                }\n            }\n        }\n\n        rd_ix += N_TILE;\n        if rd_ix >= ready_ix && partition_ix >= n_partitions {\n            break;\n        }\n        workgroupBarrier();\n    }\n    if bin_tile_x + tile_x < config.width_in_tiles && bin_tile_y + tile_y < config.height_in_tiles {\n        ptcl[cmd_offset] = CMD_END;\n        if max_blend_depth > BLEND_STACK_SPLIT {\n            let scratch_size = max_blend_depth * TILE_WIDTH * TILE_HEIGHT;\n            ptcl[blend_offset] = atomicAdd(&bump.blend, scratch_size);\n        }\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 8192, index: 0 },
      { size_in_bytes: 1024, index: 1 },
      { size_in_bytes: 1024, index: 2 },
      { size_in_bytes: 1024, index: 3 },
      { size_in_bytes: 1024, index: 4 },
      { size_in_bytes: 1024, index: 5 },
      { size_in_bytes: 1024, index: 6 },
      { size_in_bytes: 1024, index: 7 },
      { size_in_bytes: 1024, index: 8 }
    ]
  },
  draw_leaf: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Finish prefix sum of drawtags, decode draw objects.\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n \nstruct Bic {\n    a: u32,\n    b: u32,\n}\n\nfn bic_combine(x: Bic, y: Bic) -> Bic {\n    let m = min(x.b, y.a);\n    return Bic(x.a + y.a - m, x.b + y.b - m);\n}\n\nstruct ClipInp {\n    // Index of the draw object.\n    ix: u32,\n    // This is a packed encoding of an enum with the sign bit as the tag. If positive,\n    // this entry is a BeginClip and contains the associated path index. If negative,\n    // it is an EndClip and contains the bitwise-not of the EndClip draw object index.\n    path_ix: i32,\n}\n\nstruct ClipEl {\n    parent_ix: u32,\n    bbox: vec4<f32>,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The DrawMonoid is computed as a prefix sum to aid in decoding\n// the variable-length encoding of draw objects.\nstruct DrawMonoid {\n    // The number of paths preceding this draw object.\n    path_ix: u32,\n    // The number of clip operations preceding this draw object.\n    clip_ix: u32,\n    // The offset of the encoded draw object in the scene (u32s).\n    scene_offset: u32,\n    // The offset of the associated info.\n    info_offset: u32,\n}\n\n// Each draw object has a 32-bit draw tag, which is a bit-packed\n// version of the draw monoid.\nconst DRAWTAG_NOP = 0u;\nconst DRAWTAG_FILL_COLOR = 0x44u;\nconst DRAWTAG_FILL_LIN_GRADIENT = 0x114u;\nconst DRAWTAG_FILL_RAD_GRADIENT = 0x29cu;\nconst DRAWTAG_FILL_IMAGE = 0x248u;\nconst DRAWTAG_BEGIN_CLIP = 0x9u;\nconst DRAWTAG_END_CLIP = 0x21u;\n\nfn draw_monoid_identity() -> DrawMonoid {\n    return DrawMonoid();\n}\n\nfn combine_draw_monoid(a: DrawMonoid, b: DrawMonoid) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = a.path_ix + b.path_ix;\n    c.clip_ix = a.clip_ix + b.clip_ix;\n    c.scene_offset = a.scene_offset + b.scene_offset;\n    c.info_offset = a.info_offset + b.info_offset;\n    return c;\n}\n\nfn map_draw_tag(tag_word: u32) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = u32(tag_word != DRAWTAG_NOP);\n    c.clip_ix = tag_word & 1u;\n    c.scene_offset = (tag_word >> 2u) & 0x07u;\n    c.info_offset = (tag_word >> 6u) & 0x0fu;\n    return c;\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The annotated bounding box for a path. It has been transformed,\n// but contains a link to the active transform, mostly for gradients.\n// Coordinates are integer pixels (for the convenience of atomic update)\n// but will probably become fixed-point fractions for rectangles.\nstruct PathBbox {\n    x0: i32,\n    y0: i32,\n    x1: i32,\n    y1: i32,\n    linewidth: f32,\n    trans_ix: u32,\n}\n\nfn bbox_intersect(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\n    return vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Helpers for working with transforms.\n\nstruct Transform {\n    matrx: vec4<f32>,\n    translate: vec2<f32>,\n}\n\nfn transform_apply(transform: Transform, p: vec2<f32>) -> vec2<f32> {\n    return transform.matrx.xy * p.x + transform.matrx.zw * p.y + transform.translate;\n}\n\nfn transform_inverse(transform: Transform) -> Transform {\n    let inv_det = 1.0 / (transform.matrx.x * transform.matrx.w - transform.matrx.y * transform.matrx.z);\n    let inv_mat = inv_det * vec4(transform.matrx.w, -transform.matrx.y, -transform.matrx.z, transform.matrx.x);\n    let inv_tr = mat2x2(inv_mat.xy, inv_mat.zw) * -transform.translate;\n    return Transform(inv_mat, inv_tr);\n}\n\nfn transform_mul(a: Transform, b: Transform) -> Transform {\n    return Transform(\n        a.matrx.xyxy * b.matrx.xxzz + a.matrx.zwzw * b.matrx.yyww,\n        a.matrx.xy * b.translate.x + a.matrx.zw * b.translate.y + a.translate\n    );\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage> reduced: array<DrawMonoid>;\n\n@group(0) @binding(3)\nvar<storage> path_bbox: array<PathBbox>;\n\n@group(0) @binding(4)\nvar<storage, read_write> draw_monoid: array<DrawMonoid>;\n\n@group(0) @binding(5)\nvar<storage, read_write> info: array<u32>;\n\n@group(0) @binding(6)\nvar<storage, read_write> clip_inp: array<ClipInp>;\n\nconst WG_SIZE = 256u;\n\nfn read_transform(transform_base: u32, ix: u32) -> Transform {\n    let base = transform_base + ix * 6u;\n    let c0 = bitcast<f32>(scene[base]);\n    let c1 = bitcast<f32>(scene[base + 1u]);\n    let c2 = bitcast<f32>(scene[base + 2u]);\n    let c3 = bitcast<f32>(scene[base + 3u]);\n    let c4 = bitcast<f32>(scene[base + 4u]);\n    let c5 = bitcast<f32>(scene[base + 5u]);\n    let matrx = vec4(c0, c1, c2, c3);\n    let translate = vec2(c4, c5);\n    return Transform(matrx, translate);\n}\n\nvar<workgroup> sh_scratch: array<DrawMonoid, WG_SIZE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n    let ix = global_id.x;\n    // Reduce prefix of workgroups up to this one\n    var agg = draw_monoid_identity();\n    if local_id.x < wg_id.x {\n        agg = reduced[local_id.x];\n    }\n    sh_scratch[local_id.x] = agg;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x + (1u << i) < WG_SIZE {\n            let other = sh_scratch[local_id.x + (1u << i)];\n            agg = combine_draw_monoid(agg, other);\n        }\n        workgroupBarrier();\n        sh_scratch[local_id.x] = agg;\n    }\n    // Two barriers can be eliminated if we use separate shared arrays\n    // for prefix and intra-workgroup prefix sum.\n    workgroupBarrier();\n    var m = sh_scratch[0];\n    workgroupBarrier();\n    let tag_word = scene[config.drawtag_base + ix];\n    agg = map_draw_tag(tag_word);\n    sh_scratch[local_id.x] = agg;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x >= 1u << i {\n            let other = sh_scratch[local_id.x - (1u << i)];\n            agg = combine_draw_monoid(agg, other);\n        }\n        workgroupBarrier();\n        sh_scratch[local_id.x] = agg;\n    }\n    workgroupBarrier();\n    if local_id.x > 0u {\n        m = combine_draw_monoid(m, sh_scratch[local_id.x - 1u]);\n    }\n    // m now contains exclusive prefix sum of draw monoid\n    draw_monoid[ix] = m;\n    let dd = config.drawdata_base + m.scene_offset;\n    let di = m.info_offset;\n    if tag_word == DRAWTAG_FILL_COLOR || tag_word == DRAWTAG_FILL_LIN_GRADIENT ||\n        tag_word == DRAWTAG_FILL_RAD_GRADIENT || tag_word == DRAWTAG_FILL_IMAGE ||\n        tag_word == DRAWTAG_BEGIN_CLIP\n    {\n        let bbox = path_bbox[m.path_ix];\n        // TODO: bbox is mostly yagni here, sort that out. Maybe clips?\n        // let x0 = f32(bbox.x0);\n        // let y0 = f32(bbox.y0);\n        // let x1 = f32(bbox.x1);\n        // let y1 = f32(bbox.y1);\n        // let bbox_f = vec4(x0, y0, x1, y1);\n        let fill_mode = u32(bbox.linewidth >= 0.0);\n        var transform = Transform();\n        var linewidth = bbox.linewidth;\n        if linewidth >= 0.0 || tag_word == DRAWTAG_FILL_LIN_GRADIENT || tag_word == DRAWTAG_FILL_RAD_GRADIENT ||\n            tag_word == DRAWTAG_FILL_IMAGE \n        {\n            transform = read_transform(config.transform_base, bbox.trans_ix);\n        }\n        if linewidth >= 0.0 {\n            // Note: doesn't deal with anisotropic case\n            let matrx = transform.matrx;\n            linewidth *= sqrt(abs(matrx.x * matrx.w - matrx.y * matrx.z));\n        }\n        switch tag_word {\n            // DRAWTAG_FILL_COLOR\n            case 0x44u: {\n                info[di] = bitcast<u32>(linewidth);\n            }\n            // DRAWTAG_FILL_LIN_GRADIENT\n            case 0x114u: {\n                info[di] = bitcast<u32>(linewidth);\n                var p0 = bitcast<vec2<f32>>(vec2(scene[dd + 1u], scene[dd + 2u]));\n                var p1 = bitcast<vec2<f32>>(vec2(scene[dd + 3u], scene[dd + 4u]));\n                p0 = transform_apply(transform, p0);\n                p1 = transform_apply(transform, p1);\n                let dxy = p1 - p0;\n                let scale = 1.0 / dot(dxy, dxy);\n                let line_xy = dxy * scale;\n                let line_c = -dot(p0, line_xy);\n                info[di + 1u] = bitcast<u32>(line_xy.x);\n                info[di + 2u] = bitcast<u32>(line_xy.y);\n                info[di + 3u] = bitcast<u32>(line_c);\n            }\n            // DRAWTAG_FILL_RAD_GRADIENT\n            case 0x29cu: {\n                // Two-point conical gradient implementation based\n                // on the algorithm at <https://skia.org/docs/dev/design/conical/>\n                // This epsilon matches what Skia uses\n                let GRADIENT_EPSILON = 1.0 / f32(1 << 12u);\n                info[di] = bitcast<u32>(linewidth);\n                var p0 = bitcast<vec2<f32>>(vec2(scene[dd + 1u], scene[dd + 2u]));\n                var p1 = bitcast<vec2<f32>>(vec2(scene[dd + 3u], scene[dd + 4u]));\n                var r0 = bitcast<f32>(scene[dd + 5u]);\n                var r1 = bitcast<f32>(scene[dd + 6u]);\n                let user_to_gradient = transform_inverse(transform);\n                // Output variables\n                var xform = Transform();\n                var focal_x = 0.0;\n                var radius = 0.0;\n                var kind = 0u;\n                var flags = 0u;\n                if abs(r0 - r1) <= GRADIENT_EPSILON {\n                    // When the radii are the same, emit a strip gradient\n                    kind = RAD_GRAD_KIND_STRIP;\n                    let scaled = r0 / distance(p0, p1);\n                    xform = transform_mul(\n                        two_point_to_unit_line(p0, p1),\n                        user_to_gradient\n                    );\n                    radius = scaled * scaled;\n                } else {\n                    // Assume a two point conical gradient unless the centers\n                    // are equal.\n                    kind = RAD_GRAD_KIND_CONE;\n                    if all(p0 == p1) {\n                        kind = RAD_GRAD_KIND_CIRCULAR;\n                        // Nudge p0 a bit to avoid denormals.\n                        p0 += GRADIENT_EPSILON;\n                    }\n                    if r1 == 0.0 {\n                        // If r1 == 0.0, swap the points and radii\n                        flags |= RAD_GRAD_SWAPPED;\n                        let tmp_p = p0;\n                        p0 = p1;\n                        p1 = tmp_p;\n                        let tmp_r = r0;\n                        r0 = r1;\n                        r1 = tmp_r;\n                    }\n                    focal_x = r0 / (r0 - r1);\n                    let cf = (1.0 - focal_x) * p0 + focal_x * p1;\n                    radius = r1 / (distance(cf, p1));\n                    let user_to_unit_line = transform_mul(\n                        two_point_to_unit_line(cf, p1),\n                        user_to_gradient\n                    );\n                    var user_to_scaled = user_to_unit_line;\n                    // When r == 1.0, focal point is on circle\n                    if abs(radius - 1.0) <= GRADIENT_EPSILON { \n                        kind = RAD_GRAD_KIND_FOCAL_ON_CIRCLE;\n                        let scale = 0.5 * abs(1.0 - focal_x);\n                        user_to_scaled = transform_mul(\n                            Transform(vec4(scale, 0.0, 0.0, scale), vec2(0.0)),\n                            user_to_unit_line\n                        );\n                    } else {\n                        let a = radius * radius - 1.0;\n                        let scale_ratio = abs(1.0 - focal_x) / a;\n                        let scale_x = radius * scale_ratio;\n                        let scale_y = sqrt(abs(a)) * scale_ratio;\n                        user_to_scaled = transform_mul(\n                            Transform(vec4(scale_x, 0.0, 0.0, scale_y), vec2(0.0)),\n                            user_to_unit_line\n                        );\n                    }\n                    xform = user_to_scaled;\n                }\n                info[di + 1u] = bitcast<u32>(xform.matrx.x);\n                info[di + 2u] = bitcast<u32>(xform.matrx.y);\n                info[di + 3u] = bitcast<u32>(xform.matrx.z);\n                info[di + 4u] = bitcast<u32>(xform.matrx.w);\n                info[di + 5u] = bitcast<u32>(xform.translate.x);\n                info[di + 6u] = bitcast<u32>(xform.translate.y);\n                info[di + 7u] = bitcast<u32>(focal_x);\n                info[di + 8u] = bitcast<u32>(radius);\n                info[di + 9u] = bitcast<u32>((flags << 3u) | kind);\n            }\n            // DRAWTAG_FILL_IMAGE\n            case 0x248u: {\n                info[di] = bitcast<u32>(linewidth);\n                let inv = transform_inverse(transform);\n                info[di + 1u] = bitcast<u32>(inv.matrx.x);\n                info[di + 2u] = bitcast<u32>(inv.matrx.y);\n                info[di + 3u] = bitcast<u32>(inv.matrx.z);\n                info[di + 4u] = bitcast<u32>(inv.matrx.w);\n                info[di + 5u] = bitcast<u32>(inv.translate.x);\n                info[di + 6u] = bitcast<u32>(inv.translate.y);\n                info[di + 7u] = scene[dd];\n                info[di + 8u] = scene[dd + 1u];\n            }\n            default: {}\n        }\n    }\n    if tag_word == DRAWTAG_BEGIN_CLIP || tag_word == DRAWTAG_END_CLIP {\n        var path_ix = ~ix;\n        if tag_word == DRAWTAG_BEGIN_CLIP {\n            path_ix = m.path_ix;\n        }\n        clip_inp[m.clip_ix] = ClipInp(ix, i32(path_ix));\n    }\n}\n\nfn two_point_to_unit_line(p0: vec2<f32>, p1: vec2<f32>) -> Transform {\n    let tmp1 = from_poly2(p0, p1);\n    let inv = transform_inverse(tmp1);\n    let tmp2 = from_poly2(vec2(0.0), vec2(1.0, 0.0));\n    return transform_mul(tmp2, inv);\n}\n\nfn from_poly2(p0: vec2<f32>, p1: vec2<f32>) -> Transform {\n    return Transform(\n        vec4(p1.y - p0.y, p0.x - p1.x, p1.x - p0.x, p1.y - p0.y),\n        vec2(p0.x, p0.y)\n    );\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 4096, index: 0 }
    ]
  },
  draw_reduce: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The DrawMonoid is computed as a prefix sum to aid in decoding\n// the variable-length encoding of draw objects.\nstruct DrawMonoid {\n    // The number of paths preceding this draw object.\n    path_ix: u32,\n    // The number of clip operations preceding this draw object.\n    clip_ix: u32,\n    // The offset of the encoded draw object in the scene (u32s).\n    scene_offset: u32,\n    // The offset of the associated info.\n    info_offset: u32,\n}\n\n// Each draw object has a 32-bit draw tag, which is a bit-packed\n// version of the draw monoid.\nconst DRAWTAG_NOP = 0u;\nconst DRAWTAG_FILL_COLOR = 0x44u;\nconst DRAWTAG_FILL_LIN_GRADIENT = 0x114u;\nconst DRAWTAG_FILL_RAD_GRADIENT = 0x29cu;\nconst DRAWTAG_FILL_IMAGE = 0x248u;\nconst DRAWTAG_BEGIN_CLIP = 0x9u;\nconst DRAWTAG_END_CLIP = 0x21u;\n\nfn draw_monoid_identity() -> DrawMonoid {\n    return DrawMonoid();\n}\n\nfn combine_draw_monoid(a: DrawMonoid, b: DrawMonoid) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = a.path_ix + b.path_ix;\n    c.clip_ix = a.clip_ix + b.clip_ix;\n    c.scene_offset = a.scene_offset + b.scene_offset;\n    c.info_offset = a.info_offset + b.info_offset;\n    return c;\n}\n\nfn map_draw_tag(tag_word: u32) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = u32(tag_word != DRAWTAG_NOP);\n    c.clip_ix = tag_word & 1u;\n    c.scene_offset = (tag_word >> 2u) & 0x07u;\n    c.info_offset = (tag_word >> 6u) & 0x0fu;\n    return c;\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> reduced: array<DrawMonoid>;\n\nconst WG_SIZE = 256u;\n\nvar<workgroup> sh_scratch: array<DrawMonoid, WG_SIZE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n) {\n    let ix = global_id.x;\n    let tag_word = scene[config.drawtag_base + ix];\n    var agg = map_draw_tag(tag_word);\n    sh_scratch[local_id.x] = agg;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x + (1u << i) < WG_SIZE {\n            let other = sh_scratch[local_id.x + (1u << i)];\n            agg = combine_draw_monoid(agg, other);\n        }\n        workgroupBarrier();\n        sh_scratch[local_id.x] = agg;\n    }\n    if local_id.x == 0u {\n        reduced[ix >> firstTrailingBit(WG_SIZE)] = agg;\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 4096, index: 0 }
    ]
  },
  fine: {
    wgsl: `// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Fine rasterizer. This can run in simple (just path rendering) and full\n// modes, controllable by #define.\n\n// This is a cut'n'paste w/ backdrop.\nstruct Tile {\n    backdrop: i32,\n    segments: u32,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct Segment {\n    origin: vec2<f32>,\n    delta: vec2<f32>,\n    y_edge: f32,\n    next: u32,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> tiles: array<Tile>;\n\n@group(0) @binding(2)\nvar<storage> segments: array<Segment>;\n\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Color mixing modes\n\nconst MIX_NORMAL = 0u;\nconst MIX_MULTIPLY = 1u;\nconst MIX_SCREEN = 2u;\nconst MIX_OVERLAY = 3u;\nconst MIX_DARKEN = 4u;\nconst MIX_LIGHTEN = 5u;\nconst MIX_COLOR_DODGE = 6u;\nconst MIX_COLOR_BURN = 7u;\nconst MIX_HARD_LIGHT = 8u;\nconst MIX_SOFT_LIGHT = 9u;\nconst MIX_DIFFERENCE = 10u;\nconst MIX_EXCLUSION = 11u;\nconst MIX_HUE = 12u;\nconst MIX_SATURATION = 13u;\nconst MIX_COLOR = 14u;\nconst MIX_LUMINOSITY = 15u;\nconst MIX_CLIP = 128u;\n\nfn screen(cb: vec3<f32>, cs: vec3<f32>) -> vec3<f32> {\n    return cb + cs - (cb * cs);\n}\n\nfn color_dodge(cb: f32, cs: f32) -> f32 {\n    if cb == 0.0 {\n        return 0.0;\n    } else if cs == 1.0 {\n        return 1.0;\n    } else {\n        return min(1.0, cb / (1.0 - cs));\n    }\n}\n\nfn color_burn(cb: f32, cs: f32) -> f32 {\n    if cb == 1.0 {\n        return 1.0;\n    } else if cs == 0.0 {\n        return 0.0;\n    } else {\n        return 1.0 - min(1.0, (1.0 - cb) / cs);\n    }\n}\n\nfn hard_light(cb: vec3<f32>, cs: vec3<f32>) -> vec3<f32> {\n    return select(\n        screen(cb, 2.0 * cs - 1.0),\n        cb * 2.0 * cs,\n        cs <= vec3(0.5)\n    );\n}\n\nfn soft_light(cb: vec3<f32>, cs: vec3<f32>) -> vec3<f32> {\n    let d = select(\n        sqrt(cb),\n        ((16.0 * cb - 12.0) * cb + 4.0) * cb,\n        cb <= vec3(0.25)\n    );\n    return select(\n        cb + (2.0 * cs - 1.0) * (d - cb),\n        cb - (1.0 - 2.0 * cs) * cb * (1.0 - cb),\n        cs <= vec3(0.5)\n    );\n}\n\nfn sat(c: vec3<f32>) -> f32 {\n    return max(c.x, max(c.y, c.z)) - min(c.x, min(c.y, c.z));\n}\n\nfn lum(c: vec3<f32>) -> f32 {\n    let f = vec3(0.3, 0.59, 0.11);\n    return dot(c, f);\n}\n\nfn clip_color(c_in: vec3<f32>) -> vec3<f32> {\n    var c = c_in;\n    let l = lum(c);\n    let n = min(c.x, min(c.y, c.z));\n    let x = max(c.x, max(c.y, c.z));\n    if n < 0.0 {\n        c = l + (((c - l) * l) / (l - n));\n    }\n    if x > 1.0 {\n        c = l + (((c - l) * (1.0 - l)) / (x - l));\n    }\n    return c;\n}\n\nfn set_lum(c: vec3<f32>, l: f32) -> vec3<f32> {\n    return clip_color(c + (l - lum(c)));\n}\n\nfn set_sat_inner(\n    cmin: ptr<function, f32>,\n    cmid: ptr<function, f32>,\n    cmax: ptr<function, f32>,\n    s: f32\n) {\n    if *cmax > *cmin {\n        *cmid = ((*cmid - *cmin) * s) / (*cmax - *cmin);\n        *cmax = s;\n    } else {\n        *cmid = 0.0;\n        *cmax = 0.0;\n    }\n    *cmin = 0.0;\n}\n\nfn set_sat(c: vec3<f32>, s: f32) -> vec3<f32> {\n    var r = c.r;\n    var g = c.g;\n    var b = c.b;\n    if r <= g {\n        if g <= b {\n            set_sat_inner(&r, &g, &b, s);\n        } else {\n            if r <= b {\n                set_sat_inner(&r, &b, &g, s);\n            } else {\n                set_sat_inner(&b, &r, &g, s);\n            }\n        }\n    } else {\n        if r <= b {\n            set_sat_inner(&g, &r, &b, s);\n        } else {\n            if g <= b {\n                set_sat_inner(&g, &b, &r, s);\n            } else {\n                set_sat_inner(&b, &g, &r, s);\n            }\n        }\n    }\n    return vec3(r, g, b);\n}\n\n// Blends two RGB colors together. The colors are assumed to be in sRGB\n// color space, and this function does not take alpha into account.\nfn blend_mix(cb: vec3<f32>, cs: vec3<f32>, mode: u32) -> vec3<f32> {\n    var b = vec3(0.0);\n    switch mode {\n        // MIX_MULTIPLY\n        case 1u: {\n            b = cb * cs;\n        }\n        // MIX_SCREEN\n        case 2u: {\n            b = screen(cb, cs);\n        }\n        // MIX_OVERLAY\n        case 3u: {\n            b = hard_light(cs, cb);\n        }\n        // MIX_DARKEN\n        case 4u: {\n            b = min(cb, cs);\n        }\n        // MIX_LIGHTEN\n        case 5u: {\n            b = max(cb, cs);\n        }\n        // MIX_COLOR_DODGE\n        case 6u: {\n            b = vec3(color_dodge(cb.x, cs.x), color_dodge(cb.y, cs.y), color_dodge(cb.z, cs.z));\n        }\n        // MIX_COLOR_BURN\n        case 7u: {\n            b = vec3(color_burn(cb.x, cs.x), color_burn(cb.y, cs.y), color_burn(cb.z, cs.z));\n        }\n        // MIX_HARD_LIGHT\n        case 8u: {\n            b = hard_light(cb, cs);\n        }\n        // MIX_SOFT_LIGHT\n        case 9u: {\n            b = soft_light(cb, cs);\n        }\n        // MIX_DIFFERENCE\n        case 10u: {\n            b = abs(cb - cs);\n        }\n        // MIX_EXCLUSION\n        case 11u: {\n            b = cb + cs - 2.0 * cb * cs;\n        }\n        // MIX_HUE\n        case 12u: {\n            b = set_lum(set_sat(cs, sat(cb)), lum(cb));\n        }\n        // MIX_SATURATION\n        case 13u: {\n            b = set_lum(set_sat(cb, sat(cs)), lum(cb));\n        }\n        // MIX_COLOR\n        case 14u: {\n            b = set_lum(cs, lum(cb));\n        }\n        // MIX_LUMINOSITY\n        case 15u: {\n            b = set_lum(cb, lum(cs));\n        }\n        default: {\n            b = cs;\n        }\n    }\n    return b;\n}\n\n// Composition modes\n\nconst COMPOSE_CLEAR = 0u;\nconst COMPOSE_COPY = 1u;\nconst COMPOSE_DEST = 2u;\nconst COMPOSE_SRC_OVER = 3u;\nconst COMPOSE_DEST_OVER = 4u;\nconst COMPOSE_SRC_IN = 5u;\nconst COMPOSE_DEST_IN = 6u;\nconst COMPOSE_SRC_OUT = 7u;\nconst COMPOSE_DEST_OUT = 8u;\nconst COMPOSE_SRC_ATOP = 9u;\nconst COMPOSE_DEST_ATOP = 10u;\nconst COMPOSE_XOR = 11u;\nconst COMPOSE_PLUS = 12u;\nconst COMPOSE_PLUS_LIGHTER = 13u;\n\n// Apply general compositing operation.\n// Inputs are separated colors and alpha, output is premultiplied.\nfn blend_compose(\n    cb: vec3<f32>,\n    cs: vec3<f32>,\n    ab: f32,\n    as_: f32,\n    mode: u32\n) -> vec4<f32> {\n    var fa = 0.0;\n    var fb = 0.0;\n    switch mode {\n        // COMPOSE_COPY\n        case 1u: {\n            fa = 1.0;\n            fb = 0.0;\n        }\n        // COMPOSE_DEST\n        case 2u: {\n            fa = 0.0;\n            fb = 1.0;\n        }\n        // COMPOSE_SRC_OVER\n        case 3u: {\n            fa = 1.0;\n            fb = 1.0 - as_;\n        }\n        // COMPOSE_DEST_OVER\n        case 4u: {\n            fa = 1.0 - ab;\n            fb = 1.0;\n        }\n        // COMPOSE_SRC_IN\n        case 5u: {\n            fa = ab;\n            fb = 0.0;\n        }\n        // COMPOSE_DEST_IN\n        case 6u: {\n            fa = 0.0;\n            fb = as_;\n        }\n        // COMPOSE_SRC_OUT\n        case 7u: {\n            fa = 1.0 - ab;\n            fb = 0.0;\n        }\n        // COMPOSE_DEST_OUT\n        case 8u: {\n            fa = 0.0;\n            fb = 1.0 - as_;\n        }\n        // COMPOSE_SRC_ATOP\n        case 9u: {\n            fa = ab;\n            fb = 1.0 - as_;\n        }\n        // COMPOSE_DEST_ATOP\n        case 10u: {\n            fa = 1.0 - ab;\n            fb = as_;\n        }\n        // COMPOSE_XOR\n        case 11u: {\n            fa = 1.0 - ab;\n            fb = 1.0 - as_;\n        }\n        // COMPOSE_PLUS\n        case 12u: {\n            fa = 1.0;\n            fb = 1.0;\n        }\n        // COMPOSE_PLUS_LIGHTER\n        case 13u: {\n            return min(vec4(1.0), vec4(as_ * cs + ab * cb, as_ + ab));\n        }\n        default: {}\n    }\n    let as_fa = as_ * fa;\n    let ab_fb = ab * fb;\n    let co = as_fa * cs + ab_fb * cb;\n    // Modes like COMPOSE_PLUS can generate alpha > 1.0, so clamp.\n    return vec4(co, min(as_fa + ab_fb, 1.0));\n}\n\n// Apply color mixing and composition. Both input and output colors are\n// premultiplied RGB.\nfn blend_mix_compose(backdrop: vec4<f32>, src: vec4<f32>, mode: u32) -> vec4<f32> {\n    let BLEND_DEFAULT = ((MIX_NORMAL << 8u) | COMPOSE_SRC_OVER);\n    let EPSILON = 1e-15;\n    if (mode & 0x7fffu) == BLEND_DEFAULT {\n        // Both normal+src_over blend and clip case\n        return backdrop * (1.0 - src.a) + src;\n    }\n    // Un-premultiply colors for blending. Max with a small epsilon to avoid NaNs.\n    let inv_src_a = 1.0 / max(src.a, EPSILON);\n    var cs = src.rgb * inv_src_a;\n    let inv_backdrop_a = 1.0 / max(backdrop.a, EPSILON);\n    let cb = backdrop.rgb * inv_backdrop_a;\n    let mix_mode = mode >> 8u;\n    let mixed = blend_mix(cb, cs, mix_mode);\n    cs = mix(cs, mixed, backdrop.a);\n    let compose_mode = mode & 0xffu;\n    if compose_mode == COMPOSE_SRC_OVER {\n        let co = mix(backdrop.rgb, cs, src.a);\n        return vec4(co, src.a + backdrop.a * (1.0 - src.a));\n    } else {\n        return blend_compose(cb, cs, backdrop.a, src.a, compose_mode);\n    }\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Layout of per-tile command list\n// Initial allocation, in u32's.\nconst PTCL_INITIAL_ALLOC = 64u;\nconst PTCL_INCREMENT = 256u;\n\n// Amount of space taken by jump\nconst PTCL_HEADROOM = 2u;\n\n// Tags for PTCL commands\nconst CMD_END = 0u;\nconst CMD_FILL = 1u;\nconst CMD_STROKE = 2u;\nconst CMD_SOLID = 3u;\nconst CMD_COLOR = 5u;\nconst CMD_LIN_GRAD = 6u;\nconst CMD_RAD_GRAD = 7u;\nconst CMD_IMAGE = 8u;\nconst CMD_BEGIN_CLIP = 9u;\nconst CMD_END_CLIP = 10u;\nconst CMD_JUMP = 11u;\n\n// The individual PTCL structs are written here, but read/write is by\n// hand in the relevant shaders\n\nstruct CmdFill {\n    tile: u32,\n    backdrop: i32,\n}\n\nstruct CmdStroke {\n    tile: u32,\n    half_width: f32,\n}\n\nstruct CmdJump {\n    new_ix: u32,\n}\n\nstruct CmdColor {\n    rgba_color: u32,\n}\n\nstruct CmdLinGrad {\n    index: u32,\n    extend_mode: u32,\n    line_x: f32,\n    line_y: f32,\n    line_c: f32,\n}\n\nstruct CmdRadGrad {\n    index: u32,\n    extend_mode: u32,\n    matrx: vec4<f32>,\n    xlat: vec2<f32>,\n    focal_x: f32,\n    radius: f32,\n    kind: u32,\n    flags: u32,\n}\n\nstruct CmdImage {\n    matrx: vec4<f32>,\n    xlat: vec2<f32>,\n    atlas_offset: vec2<f32>,\n    extents: vec2<f32>,\n}\n\nstruct CmdEndClip {\n    blend: u32,\n    alpha: f32,\n}\n\n\nconst GRADIENT_WIDTH = 512;\n\n@group(0) @binding(3)\nvar output: texture_storage_2d<${format}, write>;\n\n@group(0) @binding(4)\nvar<storage> ptcl: array<u32>;\n\n@group(0) @binding(5)\nvar gradients: texture_2d<f32>;\n\n@group(0) @binding(6)\nvar<storage> info: array<u32>;\n\n@group(0) @binding(7)\nvar image_atlas: texture_2d<f32>;\n\nfn read_fill(cmd_ix: u32) -> CmdFill {\n    let tile = ptcl[cmd_ix + 1u];\n    let backdrop = i32(ptcl[cmd_ix + 2u]);\n    return CmdFill(tile, backdrop);\n}\n\nfn read_stroke(cmd_ix: u32) -> CmdStroke {\n    let tile = ptcl[cmd_ix + 1u];\n    let half_width = bitcast<f32>(ptcl[cmd_ix + 2u]);\n    return CmdStroke(tile, half_width);\n}\n\nfn read_color(cmd_ix: u32) -> CmdColor {\n    let rgba_color = ptcl[cmd_ix + 1u];\n    return CmdColor(rgba_color);\n}\n\nfn read_lin_grad(cmd_ix: u32) -> CmdLinGrad {\n    let index_mode = ptcl[cmd_ix + 1u];\n    let index = index_mode >> 2u;\n    let extend_mode = index_mode & 0x3u;\n    let info_offset = ptcl[cmd_ix + 2u];\n    let line_x = bitcast<f32>(info[info_offset]);\n    let line_y = bitcast<f32>(info[info_offset + 1u]);\n    let line_c = bitcast<f32>(info[info_offset + 2u]);\n    return CmdLinGrad(index, extend_mode, line_x, line_y, line_c);\n}\n\nfn read_rad_grad(cmd_ix: u32) -> CmdRadGrad {\n    let index_mode = ptcl[cmd_ix + 1u];\n    let index = index_mode >> 2u;\n    let extend_mode = index_mode & 0x3u;\n    let info_offset = ptcl[cmd_ix + 2u];\n    let m0 = bitcast<f32>(info[info_offset]);\n    let m1 = bitcast<f32>(info[info_offset + 1u]);\n    let m2 = bitcast<f32>(info[info_offset + 2u]);\n    let m3 = bitcast<f32>(info[info_offset + 3u]);\n    let matrx = vec4(m0, m1, m2, m3);\n    let xlat = vec2(bitcast<f32>(info[info_offset + 4u]), bitcast<f32>(info[info_offset + 5u]));\n    let focal_x = bitcast<f32>(info[info_offset + 6u]);\n    let radius = bitcast<f32>(info[info_offset + 7u]);\n    let flags_kind = info[info_offset + 8u];\n    let flags = flags_kind >> 3u;\n    let kind = flags_kind & 0x7u;\n    return CmdRadGrad(index, extend_mode, matrx, xlat, focal_x, radius, kind, flags);\n}\n\nfn read_image(cmd_ix: u32) -> CmdImage {\n    let info_offset = ptcl[cmd_ix + 1u];\n    let m0 = bitcast<f32>(info[info_offset]);\n    let m1 = bitcast<f32>(info[info_offset + 1u]);\n    let m2 = bitcast<f32>(info[info_offset + 2u]);\n    let m3 = bitcast<f32>(info[info_offset + 3u]);\n    let matrx = vec4(m0, m1, m2, m3);\n    let xlat = vec2(bitcast<f32>(info[info_offset + 4u]), bitcast<f32>(info[info_offset + 5u]));\n    let xy = info[info_offset + 6u];\n    let width_height = info[info_offset + 7u];\n    // The following are not intended to be bitcasts\n    let x = f32(xy >> 16u);\n    let y = f32(xy & 0xffffu);\n    let width = f32(width_height >> 16u);\n    let height = f32(width_height & 0xffffu);\n    return CmdImage(matrx, xlat, vec2(x, y), vec2(width, height));\n}\n\nfn read_end_clip(cmd_ix: u32) -> CmdEndClip {\n    let blend = ptcl[cmd_ix + 1u];\n    let alpha = bitcast<f32>(ptcl[cmd_ix + 2u]);\n    return CmdEndClip(blend, alpha);\n}\n\nfn extend_mode(t: f32, mode: u32) -> f32 {\n    let EXTEND_PAD = 0u;\n    let EXTEND_REPEAT = 1u;\n    let EXTEND_REFLECT = 2u;\n    switch mode {\n        // EXTEND_PAD\n        case 0u: {\n            return clamp(t, 0.0, 1.0);\n        }\n        // EXTEND_REPEAT\n        case 1u: {\n            return fract(t);\n        }\n        // EXTEND_REFLECT\n        default: {\n            return abs(t - 2.0 * round(0.5 * t));\n        }\n    }\n}\n\n\nconst PIXELS_PER_THREAD = 4u;\n\nfn fill_path(tile: Tile, xy: vec2<f32>, even_odd: bool) -> array<f32, PIXELS_PER_THREAD> {\n    var area: array<f32, PIXELS_PER_THREAD>;\n    let backdrop_f = f32(tile.backdrop);\n    for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n        area[i] = backdrop_f;\n    }\n    var segment_ix = tile.segments;\n    while segment_ix != 0u {\n        let segment = segments[segment_ix];\n        let y = segment.origin.y - xy.y;\n        let y0 = clamp(y, 0.0, 1.0);\n        let y1 = clamp(y + segment.delta.y, 0.0, 1.0);\n        let dy = y0 - y1;\n        if dy != 0.0 {\n            let vec_y_recip = 1.0 / segment.delta.y;\n            let t0 = (y0 - y) * vec_y_recip;\n            let t1 = (y1 - y) * vec_y_recip;\n            let startx = segment.origin.x - xy.x;\n            let x0 = startx + t0 * segment.delta.x;\n            let x1 = startx + t1 * segment.delta.x;\n            let xmin0 = min(x0, x1);\n            let xmax0 = max(x0, x1);\n            for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n                let i_f = f32(i);\n                let xmin = min(xmin0 - i_f, 1.0) - 1.0e-6;\n                let xmax = xmax0 - i_f;\n                let b = min(xmax, 1.0);\n                let c = max(b, 0.0);\n                let d = max(xmin, 0.0);\n                let a = (b + 0.5 * (d * d - c * c) - xmin) / (xmax - xmin);\n                area[i] += a * dy;\n            }\n        }\n        let y_edge = sign(segment.delta.x) * clamp(xy.y - segment.y_edge + 1.0, 0.0, 1.0);\n        for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n            area[i] += y_edge;\n        }\n        segment_ix = segment.next;\n    }\n    if even_odd {\n        // even-odd winding rule\n        for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n            let a = area[i];\n            area[i] = abs(a - 2.0 * round(0.5 * a));\n        }\n    } else {\n        // non-zero winding rule\n        for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n            area[i] = min(abs(area[i]), 1.0);\n        }\n    }\n    return area;\n}\n\nfn stroke_path(seg: u32, half_width: f32, xy: vec2<f32>) -> array<f32, PIXELS_PER_THREAD> {\n    var df: array<f32, PIXELS_PER_THREAD>;\n    for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n        df[i] = 1e9;\n    }\n    var segment_ix = seg;\n    while segment_ix != 0u {\n        let segment = segments[segment_ix];\n        let delta = segment.delta;\n        let dpos0 = xy + vec2(0.5, 0.5) - segment.origin;\n        let scale = 1.0 / dot(delta, delta);\n        for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n            let dpos = vec2(dpos0.x + f32(i), dpos0.y);\n            let t = clamp(dot(dpos, delta) * scale, 0.0, 1.0);\n            // performance idea: hoist sqrt out of loop\n            df[i] = min(df[i], length(delta * t - dpos));\n        }\n        segment_ix = segment.next;\n    }\n    for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n        // reuse array; return alpha rather than distance\n        df[i] = clamp(half_width + 0.5 - df[i], 0.0, 1.0);\n    }\n    return df;\n}\n\n// The X size should be 16 / PIXELS_PER_THREAD\n@compute @workgroup_size(4, 16)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n    let tile_ix = wg_id.y * config.width_in_tiles + wg_id.x;\n    let xy = vec2(f32(global_id.x * PIXELS_PER_THREAD), f32(global_id.y));\n    var rgba: array<vec4<f32>, PIXELS_PER_THREAD>;\n    for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n        rgba[i] = unpack4x8unorm(config.base_color).wzyx;\n    }\n    var blend_stack: array<array<u32, PIXELS_PER_THREAD>, BLEND_STACK_SPLIT>;\n    var clip_depth = 0u;\n    var area: array<f32, PIXELS_PER_THREAD>;\n    var cmd_ix = tile_ix * PTCL_INITIAL_ALLOC;\n    let blend_offset = ptcl[cmd_ix];\n    cmd_ix += 1u;\n    // main interpretation loop\n    while true {\n        let tag = ptcl[cmd_ix];\n        if tag == CMD_END {\n            break;\n        }\n        switch tag {\n            // CMD_FILL\n            case 1u: {\n                let fill = read_fill(cmd_ix);\n                let segments = fill.tile >> 1u;\n                let even_odd = (fill.tile & 1u) != 0u;\n                let tile = Tile(fill.backdrop, segments);\n                area = fill_path(tile, xy, even_odd);\n                cmd_ix += 3u;\n            }\n            // CMD_STROKE\n            case 2u: {\n                let stroke = read_stroke(cmd_ix);\n                area = stroke_path(stroke.tile, stroke.half_width, xy);\n                cmd_ix += 3u;\n            }\n            // CMD_SOLID\n            case 3u: {\n                for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n                    area[i] = 1.0;\n                }\n                cmd_ix += 1u;\n            }\n            // CMD_COLOR\n            case 5u: {\n                let color = read_color(cmd_ix);\n                let fg = unpack4x8unorm(color.rgba_color).wzyx;\n                for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n                    let fg_i = fg * area[i];\n                    rgba[i] = rgba[i] * (1.0 - fg_i.a) + fg_i;\n                }\n                cmd_ix += 2u;\n            }\n            // CMD_LIN_GRAD\n            case 6u: {\n                let lin = read_lin_grad(cmd_ix);\n                let d = lin.line_x * xy.x + lin.line_y * xy.y + lin.line_c;\n                for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n                    let my_d = d + lin.line_x * f32(i);\n                    let x = i32(round(extend_mode(my_d, lin.extend_mode) * f32(GRADIENT_WIDTH - 1)));\n                    let fg_rgba = textureLoad(gradients, vec2(x, i32(lin.index)), 0);\n                    let fg_i = fg_rgba * area[i];\n                    rgba[i] = rgba[i] * (1.0 - fg_i.a) + fg_i;\n                }\n                cmd_ix += 3u;\n            }\n            // CMD_RAD_GRAD\n            case 7u: {\n                let rad = read_rad_grad(cmd_ix);\n                let focal_x = rad.focal_x;\n                let radius = rad.radius;\n                let is_strip = rad.kind == RAD_GRAD_KIND_STRIP;\n                let is_circular = rad.kind == RAD_GRAD_KIND_CIRCULAR;\n                let is_focal_on_circle = rad.kind == RAD_GRAD_KIND_FOCAL_ON_CIRCLE;\n                let is_swapped = (rad.flags & RAD_GRAD_SWAPPED) != 0u;\n                let r1_recip = select(1.0 / radius, 0.0, is_circular);\n                let less_scale = select(1.0, -1.0, is_swapped || (1.0 - focal_x) < 0.0);\n                let t_sign = sign(1.0 - focal_x);\n                for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n                    let my_xy = vec2(xy.x + f32(i), xy.y);\n                    let local_xy = rad.matrx.xy * my_xy.x + rad.matrx.zw * my_xy.y + rad.xlat;\n                    let x = local_xy.x;\n                    let y = local_xy.y;\n                    let xx = x * x;\n                    let yy = y * y;\n                    var t = 0.0;\n                    var is_valid = true;\n                    if is_strip {\n                        let a = radius - yy;\n                        t = sqrt(a) + x;\n                        is_valid = a >= 0.0;\n                    } else if is_focal_on_circle {\n                        t = (xx + yy) / x;\n                        is_valid = t >= 0.0 && x != 0.0;\n                    } else if radius > 1.0 {\n                        t = sqrt(xx + yy) - x * r1_recip;\n                    } else { // radius < 1.0\n                        let a = xx - yy;\n                        t = less_scale * sqrt(a) - x * r1_recip;\n                        is_valid = a >= 0.0 && t >= 0.0;\n                    }\n                    if is_valid {\n                        t = extend_mode(focal_x + t_sign * t, rad.extend_mode);\n                        t = select(t, 1.0 - t, is_swapped);\n                        let x = i32(round(t * f32(GRADIENT_WIDTH - 1)));\n                        let fg_rgba = textureLoad(gradients, vec2(x, i32(rad.index)), 0);\n                        let fg_i = fg_rgba * area[i];\n                        rgba[i] = rgba[i] * (1.0 - fg_i.a) + fg_i;\n                    }\n                }\n                cmd_ix += 3u;\n            }\n            // CMD_IMAGE\n            case 8u: {\n                let image = read_image(cmd_ix);\n                let atlas_extents = image.atlas_offset + image.extents;\n                for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n                    let my_xy = vec2(xy.x + f32(i), xy.y);\n                    let atlas_uv = image.matrx.xy * my_xy.x + image.matrx.zw * my_xy.y + image.xlat + image.atlas_offset;\n                    // This currently clips to the image bounds. TODO: extend modes\n                    if all(atlas_uv < atlas_extents) && area[i] != 0.0 {\n                        let uv_quad = vec4(max(floor(atlas_uv), image.atlas_offset), min(ceil(atlas_uv), atlas_extents));\n                        let uv_frac = fract(atlas_uv);\n                        let a = premul_alpha(textureLoad(image_atlas, vec2<i32>(uv_quad.xy), 0));\n                        let b = premul_alpha(textureLoad(image_atlas, vec2<i32>(uv_quad.xw), 0));\n                        let c = premul_alpha(textureLoad(image_atlas, vec2<i32>(uv_quad.zy), 0));\n                        let d = premul_alpha(textureLoad(image_atlas, vec2<i32>(uv_quad.zw), 0));\n                        let fg_rgba = mix(mix(a, b, uv_frac.y), mix(c, d, uv_frac.y), uv_frac.x);\n                        let fg_i = fg_rgba * area[i];\n                        rgba[i] = rgba[i] * (1.0 - fg_i.a) + fg_i;\n                    }\n                }\n                cmd_ix += 2u;\n            }\n            // CMD_BEGIN_CLIP\n            case 9u: {\n                if clip_depth < BLEND_STACK_SPLIT {\n                    for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n                        blend_stack[clip_depth][i] = pack4x8unorm(rgba[i]);\n                        rgba[i] = vec4(0.0);\n                    }\n                } else {\n                    // TODO: spill to memory\n                }\n                clip_depth += 1u;\n                cmd_ix += 1u;\n            }\n            // CMD_END_CLIP\n            case 10u: {\n                let end_clip = read_end_clip(cmd_ix);\n                clip_depth -= 1u;\n                for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n                    var bg_rgba: u32;\n                    if clip_depth < BLEND_STACK_SPLIT {\n                        bg_rgba = blend_stack[clip_depth][i];\n                    } else {\n                        // load from memory\n                    }\n                    let bg = unpack4x8unorm(bg_rgba);\n                    let fg = rgba[i] * area[i] * end_clip.alpha;\n                    rgba[i] = blend_mix_compose(bg, fg, end_clip.blend);\n                }\n                cmd_ix += 3u;\n            }\n            // CMD_JUMP\n            case 11u: {\n                cmd_ix = ptcl[cmd_ix + 1u];\n            }\n            default: {}\n        }\n    }\n    let xy_uint = vec2<u32>(xy);\n    for (var i = 0u; i < PIXELS_PER_THREAD; i += 1u) {\n        let coords = xy_uint + vec2(i, 0u);\n        if coords.x < config.target_width && coords.y < config.target_height {\n            let fg = rgba[i];\n            // Max with a small epsilon to avoid NaNs\n            let a_inv = 1.0 / max(fg.a, 1e-6);\n            let rgba_sep = vec4(fg.rgb * a_inv, fg.a);\n            textureStore(output, vec2<i32>(coords), rgba_sep);\n        }\n    } \n}\n\nfn premul_alpha(rgba: vec4<f32>) -> vec4<f32> {\n    return vec4(rgba.rgb * rgba.a, rgba.a);\n}\n`,
    workgroup_size: [ 4, 16, 1 ],
    // TODO: Also seems incorrect
    // bindings: [ 'Uniform', 'BufReadOnly', 'Image', 'BufReadOnly', 'ImageRead', 'BufReadOnly', 'ImageRead' ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Image', 'BufReadOnly', 'ImageRead', 'BufReadOnly', 'ImageRead' ],
    workgroup_buffers: []
  },
  path_coarse: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct TagMonoid {\n    trans_ix: u32,\n    // TODO: I don't think pathseg_ix is used.\n    pathseg_ix: u32,\n    pathseg_offset: u32,\n    linewidth_ix: u32,\n    path_ix: u32,\n}\n\nconst PATH_TAG_SEG_TYPE = 3u;\nconst PATH_TAG_LINETO = 1u;\nconst PATH_TAG_QUADTO = 2u;\nconst PATH_TAG_CUBICTO = 3u;\nconst PATH_TAG_F32 = 8u;\nconst PATH_TAG_TRANSFORM = 0x20u;\nconst PATH_TAG_PATH = 0x10u;\nconst PATH_TAG_LINEWIDTH = 0x40u;\n\nfn tag_monoid_identity() -> TagMonoid {\n    return TagMonoid();\n}\n\nfn combine_tag_monoid(a: TagMonoid, b: TagMonoid) -> TagMonoid {\n    var c: TagMonoid;\n    c.trans_ix = a.trans_ix + b.trans_ix;\n    c.pathseg_ix = a.pathseg_ix + b.pathseg_ix;\n    c.pathseg_offset = a.pathseg_offset + b.pathseg_offset;\n    c.linewidth_ix = a.linewidth_ix + b.linewidth_ix;\n    c.path_ix = a.path_ix + b.path_ix;\n    return c;\n}\n\nfn reduce_tag(tag_word: u32) -> TagMonoid {\n    var c: TagMonoid;\n    let point_count = tag_word & 0x3030303u;\n    c.pathseg_ix = countOneBits((point_count * 7u) & 0x4040404u);\n    c.trans_ix = countOneBits(tag_word & (PATH_TAG_TRANSFORM * 0x1010101u));\n    let n_points = point_count + ((tag_word >> 2u) & 0x1010101u);\n    var a = n_points + (n_points & (((tag_word >> 3u) & 0x1010101u) * 15u));\n    a += a >> 8u;\n    a += a >> 16u;\n    c.pathseg_offset = a & 0xffu;\n    c.path_ix = countOneBits(tag_word & (PATH_TAG_PATH * 0x1010101u));\n    c.linewidth_ix = countOneBits(tag_word & (PATH_TAG_LINEWIDTH * 0x1010101u));\n    return c;\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage> tag_monoids: array<TagMonoid>;\n\n// We don't get this from import as it's the atomic version\nstruct AtomicTile {\n    backdrop: atomic<i32>,\n    segments: atomic<u32>,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct Segment {\n    origin: vec2<f32>,\n    delta: vec2<f32>,\n    y_edge: f32,\n    next: u32,\n}\n\n\n@group(0) @binding(3)\nvar<storage, read_write> tiles: array<AtomicTile>;\n\n@group(0) @binding(4)\nvar<storage, read_write> segments: array<Segment>;\n\nvar<private> pathdata_base: u32;\n\nfn read_f32_point(ix: u32) -> vec2<f32> {\n    let x = bitcast<f32>(scene[pathdata_base + ix]);\n    let y = bitcast<f32>(scene[pathdata_base + ix + 1u]);\n    return vec2(x, y);\n}\n\nfn read_i16_point(ix: u32) -> vec2<f32> {\n    let raw = scene[pathdata_base + ix];\n    let x = f32(i32(raw << 16u) >> 16u);\n    let y = f32(i32(raw) >> 16u);\n    return vec2(x, y);\n}\n\nstruct SubdivResult {\n    val: f32,\n    a0: f32,\n    a2: f32,\n}\n\nconst D = 0.67;\nfn approx_parabola_integral(x: f32) -> f32 {\n    return x * inverseSqrt(sqrt(1.0 - D + (D * D * D * D + 0.25 * x * x)));\n}\n\nconst B = 0.39;\nfn approx_parabola_inv_integral(x: f32) -> f32 {\n    return x * sqrt(1.0 - B + (B * B + 0.5 * x * x));\n}\n\nfn estimate_subdiv(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, sqrt_tol: f32) -> SubdivResult {\n    let d01 = p1 - p0;\n    let d12 = p2 - p1;\n    let dd = d01 - d12;\n    let cross = (p2.x - p0.x) * dd.y - (p2.y - p0.y) * dd.x;\n    let cross_inv = 1.0 / cross;\n    let x0 = dot(d01, dd) * cross_inv;\n    let x2 = dot(d12, dd) * cross_inv;\n    let scale = abs(cross / (length(dd) * (x2 - x0)));\n\n    let a0 = approx_parabola_integral(x0);\n    let a2 = approx_parabola_integral(x2);\n    var val = 0.0;\n    if scale < 1e9 {\n        let da = abs(a2 - a0);\n        let sqrt_scale = sqrt(scale);\n        if sign(x0) == sign(x2) {\n            val = sqrt_scale;\n        } else {\n            let xmin = sqrt_tol / sqrt_scale;\n            val = sqrt_tol / approx_parabola_integral(xmin);\n        }\n        val *= da;\n    }\n    return SubdivResult(val, a0, a2);\n}\n\nfn eval_quad(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, t: f32) -> vec2<f32> {\n    let mt = 1.0 - t;\n    return p0 * (mt * mt) + (p1 * (mt * 2.0) + p2 * t) * t;\n}\n\nfn eval_cubic(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>, t: f32) -> vec2<f32> {\n    let mt = 1.0 - t;\n    return p0 * (mt * mt * mt) + (p1 * (mt * mt * 3.0) + (p2 * (mt * 3.0) + p3 * t) * t) * t;\n}\n\nfn alloc_segment() -> u32 {\n    // Use 0-index segment (address is sentinel) as counter\n    // TODO: separate small buffer binding for this?\n    return atomicAdd(&tiles[4096].segments, 1u) + 1u;\n}\n\nconst MAX_QUADS = 16u;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n) {\n    // Obtain exclusive prefix sum of tag monoid\n    let ix = global_id.x;\n    let tag_word = scene[config.pathtag_base + (ix >> 2u)];\n    pathdata_base = config.pathdata_base;\n    let shift = (ix & 3u) * 8u;\n    var tm = reduce_tag(tag_word & ((1u << shift) - 1u));\n    tm = combine_tag_monoid(tag_monoids[ix >> 2u], tm);\n    var tag_byte = (tag_word >> shift) & 0xffu;\n    // should be extractBits(tag_word, shift, 8)?\n\n    // Decode path data\n    let seg_type = tag_byte & PATH_TAG_SEG_TYPE;\n    if seg_type != 0u {\n        var p0: vec2<f32>;\n        var p1: vec2<f32>;\n        var p2: vec2<f32>;\n        var p3: vec2<f32>;\n        if (tag_byte & PATH_TAG_F32) != 0u {\n            p0 = read_f32_point(tm.pathseg_offset);\n            p1 = read_f32_point(tm.pathseg_offset + 2u);\n            if seg_type >= PATH_TAG_QUADTO {\n                p2 = read_f32_point(tm.pathseg_offset + 4u);\n                if seg_type == PATH_TAG_CUBICTO {\n                    p3 = read_f32_point(tm.pathseg_offset + 6u);\n                }\n            }\n        } else {\n            p0 = read_i16_point(tm.pathseg_offset);\n            p1 = read_i16_point(tm.pathseg_offset + 1u);\n            if seg_type >= PATH_TAG_QUADTO {\n                p2 = read_i16_point(tm.pathseg_offset + 2u);\n                if seg_type == PATH_TAG_CUBICTO {\n                    p3 = read_i16_point(tm.pathseg_offset + 3u);\n                }\n            }\n        }\n        // TODO: transform goes here\n        // Degree-raise\n        if seg_type == PATH_TAG_LINETO {\n            p3 = p1;\n            p2 = mix(p3, p0, 1.0 / 3.0);\n            p1 = mix(p0, p3, 1.0 / 3.0);\n        } else if seg_type == PATH_TAG_QUADTO {\n            p3 = p2;\n            p2 = mix(p1, p2, 1.0 / 3.0);\n            p1 = mix(p1, p0, 1.0 / 3.0);\n        }\n        let err_v = 3.0 * (p2 - p1) + p0 - p3;\n        let err = dot(err_v, err_v);\n        let ACCURACY = 0.25;\n        let Q_ACCURACY = ACCURACY * 0.1;\n        let REM_ACCURACY = (ACCURACY - Q_ACCURACY);\n        let MAX_HYPOT2 = 432.0 * Q_ACCURACY * Q_ACCURACY;\n        var n_quads = max(u32(ceil(pow(err * (1.0 / MAX_HYPOT2), 1.0 / 6.0))), 1u);\n        n_quads = min(n_quads, MAX_QUADS);\n        var keep_params: array<SubdivResult, MAX_QUADS>;\n        var val = 0.0;\n        var qp0 = p0;\n        let step = 1.0 / f32(n_quads);\n        for (var i = 0u; i < n_quads; i += 1u) {\n            let t = f32(i + 1u) * step;\n            let qp2 = eval_cubic(p0, p1, p2, p3, t);\n            var qp1 = eval_cubic(p0, p1, p2, p3, t - 0.5 * step);\n            qp1 = 2.0 * qp1 - 0.5 * (qp0 + qp2);\n            let params = estimate_subdiv(qp0, qp1, qp2, sqrt(REM_ACCURACY));\n            keep_params[i] = params;\n            val += params.val;\n            qp0 = qp2;\n        }\n        let n = max(u32(ceil(val * (0.5 / sqrt(REM_ACCURACY)))), 1u);\n        var lp0 = p0;\n        qp0 = p0;\n        let v_step = val / f32(n);\n        var n_out = 1u;\n        var val_sum = 0.0;\n        for (var i = 0u; i < n_quads; i += 1u) {\n            let t = f32(i + 1u) * step;\n            let qp2 = eval_cubic(p0, p1, p2, p3, t);\n            var qp1 = eval_cubic(p0, p1, p2, p3, t - 0.5 * step);\n            qp1 = 2.0 * qp1 - 0.5 * (qp0 + qp2);\n            let params = keep_params[i];\n            let u0 = approx_parabola_inv_integral(params.a0);\n            let u2 = approx_parabola_inv_integral(params.a2);\n            let uscale = 1.0 / (u2 - u0);\n            var val_target = f32(n_out) * v_step;\n            while n_out == n || val_target < val_sum + params.val {\n                var lp1: vec2<f32>;\n                if n_out == n {\n                    lp1 = p3;\n                } else {\n                    let u = (val_target - val_sum) / params.val;\n                    let a = mix(params.a0, params.a2, u);\n                    let au = approx_parabola_inv_integral(a);\n                    let t = (au - u0) * uscale;\n                    lp1 = eval_quad(qp0, qp1, qp2, t);\n                }\n\n                // Output line segment lp0..lp1\n                let xymin = min(lp0, lp1);\n                let xymax = max(lp0, lp1);\n                let dp = lp1 - lp0;\n                let recip_dx = 1.0 / dp.x;\n                let invslope = select(dp.x / dp.y, 1.0e9, abs(dp.y) < 1.0e-9);\n                let c = 0.5 * abs(invslope);\n                let b = invslope;\n                let SX = 1.0 / f32(TILE_WIDTH);\n                let SY = 1.0 / f32(TILE_HEIGHT);\n                let a = (lp0.x - (lp0.y - 0.5 * f32(TILE_HEIGHT)) * b) * SX;\n                var x0 = i32(floor(xymin.x * SX));\n                var x1 = i32(floor(xymax.x * SX) + 1.0);\n                var y0 = i32(floor(xymin.y * SY));\n                var y1 = i32(floor(xymax.y * SY) + 1.0);\n                x0 = clamp(x0, 0, i32(config.width_in_tiles));\n                x1 = clamp(x1, 0, i32(config.width_in_tiles));\n                y0 = clamp(y0, 0, i32(config.height_in_tiles));\n                y1 = clamp(y1, 0, i32(config.height_in_tiles));\n                var xc = a + b * f32(y0);\n                var xray = i32(floor(lp0.x * SX));\n                var last_xray = i32(floor(lp1.x * SX));\n                if dp.y < 0.0 {\n                    let tmp = xray;\n                    xray = last_xray;\n                    last_xray = tmp;\n                }\n                for (var y = y0; y < y1; y += 1) {\n                    let tile_y0 = f32(y) * f32(TILE_HEIGHT);\n                    let xbackdrop = max(xray + 1, 0);\n                    if xymin.y < tile_y0 && xbackdrop < i32(config.width_in_tiles) {\n                        let backdrop = select(-1, 1, dp.y < 0.0);\n                        let tile_ix = y * i32(config.width_in_tiles) + xbackdrop;\n                        atomicAdd(&tiles[tile_ix].backdrop, backdrop);\n                    }\n                    var next_xray = last_xray;\n                    if y + 1 < y1 {\n                        let tile_y1 = f32(y + 1) * f32(TILE_HEIGHT);\n                        let x_edge = lp0.x + (tile_y1 - lp0.y) * invslope;\n                        next_xray = i32(floor(x_edge * SX));\n                    }\n                    let min_xray = min(xray, next_xray);\n                    let max_xray = max(xray, next_xray);\n                    var xx0 = min(i32(floor(xc - c)), min_xray);\n                    var xx1 = max(i32(ceil(xc + c)), max_xray + 1);\n                    xx0 = clamp(xx0, x0, x1);\n                    xx1 = clamp(xx1, x0, x1);\n                    var tile_seg: Segment;\n                    for (var x = xx0; x < xx1; x += 1) {\n                        let tile_x0 = f32(x) * f32(TILE_WIDTH);\n                        let tile_ix = y * i32(config.width_in_tiles) + x;\n                        // allocate segment, insert linked list\n                        let seg_ix = alloc_segment();\n                        let old = atomicExchange(&tiles[tile_ix].segments, seg_ix);\n                        tile_seg.origin = lp0;\n                        tile_seg.delta = dp;\n                        var y_edge = mix(lp0.y, lp1.y, (tile_x0 - lp0.x) * recip_dx);\n                        if xymin.x < tile_x0 {\n                            let p = vec2(tile_x0, y_edge);\n                            if dp.x < 0.0 {\n                                tile_seg.delta = p - lp0;\n                            } else {\n                                tile_seg.origin = p;\n                                tile_seg.delta = lp1 - p;\n                            }\n                            if tile_seg.delta.x == 0.0 {\n                                tile_seg.delta.x = sign(dp.x) * 1e-9;\n                            }\n                        }\n                        if x <= min_xray || max_xray < x {\n                            y_edge = 1e9;\n                        }\n                        tile_seg.y_edge = y_edge;\n                        tile_seg.next = old;\n                        segments[seg_ix] = tile_seg;\n                    }\n                    xc += b;\n                    xray = next_xray;\n                }\n                n_out += 1u;\n                val_target += v_step;\n                lp0 = lp1;\n            }\n            val_sum += params.val;\n            qp0 = qp2;\n        }\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
    workgroup_buffers: []
  },
  path_coarse_full: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Path coarse rasterization for the full implementation.\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct TagMonoid {\n    trans_ix: u32,\n    // TODO: I don't think pathseg_ix is used.\n    pathseg_ix: u32,\n    pathseg_offset: u32,\n    linewidth_ix: u32,\n    path_ix: u32,\n}\n\nconst PATH_TAG_SEG_TYPE = 3u;\nconst PATH_TAG_LINETO = 1u;\nconst PATH_TAG_QUADTO = 2u;\nconst PATH_TAG_CUBICTO = 3u;\nconst PATH_TAG_F32 = 8u;\nconst PATH_TAG_TRANSFORM = 0x20u;\nconst PATH_TAG_PATH = 0x10u;\nconst PATH_TAG_LINEWIDTH = 0x40u;\n\nfn tag_monoid_identity() -> TagMonoid {\n    return TagMonoid();\n}\n\nfn combine_tag_monoid(a: TagMonoid, b: TagMonoid) -> TagMonoid {\n    var c: TagMonoid;\n    c.trans_ix = a.trans_ix + b.trans_ix;\n    c.pathseg_ix = a.pathseg_ix + b.pathseg_ix;\n    c.pathseg_offset = a.pathseg_offset + b.pathseg_offset;\n    c.linewidth_ix = a.linewidth_ix + b.linewidth_ix;\n    c.path_ix = a.path_ix + b.path_ix;\n    return c;\n}\n\nfn reduce_tag(tag_word: u32) -> TagMonoid {\n    var c: TagMonoid;\n    let point_count = tag_word & 0x3030303u;\n    c.pathseg_ix = countOneBits((point_count * 7u) & 0x4040404u);\n    c.trans_ix = countOneBits(tag_word & (PATH_TAG_TRANSFORM * 0x1010101u));\n    let n_points = point_count + ((tag_word >> 2u) & 0x1010101u);\n    var a = n_points + (n_points & (((tag_word >> 3u) & 0x1010101u) * 15u));\n    a += a >> 8u;\n    a += a >> 16u;\n    c.pathseg_offset = a & 0xffu;\n    c.path_ix = countOneBits(tag_word & (PATH_TAG_PATH * 0x1010101u));\n    c.linewidth_ix = countOneBits(tag_word & (PATH_TAG_LINEWIDTH * 0x1010101u));\n    return c;\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Common datatypes for path and tile intermediate info.\n\nstruct Path {\n    // bounding box in tiles\n    bbox: vec4<u32>,\n    // offset (in u32's) to tile rectangle\n    tiles: u32,\n}\n\nstruct Tile {\n    backdrop: i32,\n    segments: u32,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct Segment {\n    origin: vec2<f32>,\n    delta: vec2<f32>,\n    y_edge: f32,\n    next: u32,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct Cubic {\n    p0: vec2<f32>,\n    p1: vec2<f32>,\n    p2: vec2<f32>,\n    p3: vec2<f32>,\n    stroke: vec2<f32>,\n    path_ix: u32,\n    flags: u32,\n}\n\nconst CUBIC_IS_STROKE = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Bitflags for each stage that can fail allocation.\nconst STAGE_BINNING: u32 = 0x1u;\nconst STAGE_TILE_ALLOC: u32 = 0x2u;\nconst STAGE_PATH_COARSE: u32 = 0x4u;\nconst STAGE_COARSE: u32 = 0x8u;\n\n// This must be kept in sync with the struct in src/render.rs\nstruct BumpAllocators {\n    // Bitmask of stages that have failed allocation.\n    failed: atomic<u32>,\n    binning: atomic<u32>,\n    ptcl: atomic<u32>,\n    tile: atomic<u32>,\n    segments: atomic<u32>,\n    blend: atomic<u32>,\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage> tag_monoids: array<TagMonoid>;\n\n@group(0) @binding(3)\nvar<storage> cubics: array<Cubic>;\n\n@group(0) @binding(4)\nvar<storage> paths: array<Path>;\n\n// We don't get this from import as it's the atomic version\nstruct AtomicTile {\n    backdrop: atomic<i32>,\n    segments: atomic<u32>,\n}\n\n@group(0) @binding(5)\nvar<storage, read_write> bump: BumpAllocators;\n\n@group(0) @binding(6)\nvar<storage, read_write> tiles: array<AtomicTile>;\n\n@group(0) @binding(7)\nvar<storage, read_write> segments: array<Segment>;\n\nstruct SubdivResult {\n    val: f32,\n    a0: f32,\n    a2: f32,\n}\n\nconst D = 0.67;\nfn approx_parabola_integral(x: f32) -> f32 {\n    return x * inverseSqrt(sqrt(1.0 - D + (D * D * D * D + 0.25 * x * x)));\n}\n\nconst B = 0.39;\nfn approx_parabola_inv_integral(x: f32) -> f32 {\n    return x * sqrt(1.0 - B + (B * B + 0.5 * x * x));\n}\n\nfn estimate_subdiv(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, sqrt_tol: f32) -> SubdivResult {\n    let d01 = p1 - p0;\n    let d12 = p2 - p1;\n    let dd = d01 - d12;\n    let cross = (p2.x - p0.x) * dd.y - (p2.y - p0.y) * dd.x;\n    let cross_inv = select(1.0 / cross, 1.0e9, abs(cross) < 1.0e-9);\n    let x0 = dot(d01, dd) * cross_inv;\n    let x2 = dot(d12, dd) * cross_inv;\n    let scale = abs(cross / (length(dd) * (x2 - x0)));\n\n    let a0 = approx_parabola_integral(x0);\n    let a2 = approx_parabola_integral(x2);\n    var val = 0.0;\n    if scale < 1e9 {\n        let da = abs(a2 - a0);\n        let sqrt_scale = sqrt(scale);\n        if sign(x0) == sign(x2) {\n            val = sqrt_scale;\n        } else {\n            let xmin = sqrt_tol / sqrt_scale;\n            val = sqrt_tol / approx_parabola_integral(xmin);\n        }\n        val *= da;\n    }\n    return SubdivResult(val, a0, a2);\n}\n\nfn eval_quad(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, t: f32) -> vec2<f32> {\n    let mt = 1.0 - t;\n    return p0 * (mt * mt) + (p1 * (mt * 2.0) + p2 * t) * t;\n}\n\nfn eval_cubic(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>, t: f32) -> vec2<f32> {\n    let mt = 1.0 - t;\n    return p0 * (mt * mt * mt) + (p1 * (mt * mt * 3.0) + (p2 * (mt * 3.0) + p3 * t) * t) * t;\n}\n\nfn alloc_segment() -> u32 {\n    var offset = atomicAdd(&bump.segments, 1u) + 1u;\n    if offset + 1u > config.segments_size {\n        offset = 0u;\n        atomicOr(&bump.failed, STAGE_PATH_COARSE);\n    }\n    return offset;\n}\n\nconst MAX_QUADS = 16u;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n) {\n    // Exit early if prior stages failed, as we can't run this stage.\n    // We need to check only prior stages, as if this stage has failed in another workgroup, \n    // we still want to know this workgroup's memory requirement.   \n    if (atomicLoad(&bump.failed) & (STAGE_BINNING | STAGE_TILE_ALLOC)) != 0u {\n        return;\n    }\n    let ix = global_id.x;\n    let tag_word = scene[config.pathtag_base + (ix >> 2u)];\n    let shift = (ix & 3u) * 8u;\n    var tag_byte = (tag_word >> shift) & 0xffu;\n\n    if (tag_byte & PATH_TAG_SEG_TYPE) != 0u {\n        // Discussion question: it might actually be cheaper to do the path segment\n        // decoding & transform again rather than store the result in a buffer;\n        // classic memory vs ALU tradeoff.\n        let cubic = cubics[global_id.x];\n        let path = paths[cubic.path_ix];\n        let is_stroke = (cubic.flags & CUBIC_IS_STROKE) != 0u;\n        let bbox = vec4<i32>(path.bbox);\n        let p0 = cubic.p0;\n        let p1 = cubic.p1;\n        let p2 = cubic.p2;\n        let p3 = cubic.p3;\n        let err_v = 3.0 * (p2 - p1) + p0 - p3;\n        let err = dot(err_v, err_v);\n        let ACCURACY = 0.25;\n        let Q_ACCURACY = ACCURACY * 0.1;\n        let REM_ACCURACY = (ACCURACY - Q_ACCURACY);\n        let MAX_HYPOT2 = 432.0 * Q_ACCURACY * Q_ACCURACY;\n        var n_quads = max(u32(ceil(pow(err * (1.0 / MAX_HYPOT2), 1.0 / 6.0))), 1u);\n        n_quads = min(n_quads, MAX_QUADS);\n        var keep_params: array<SubdivResult, MAX_QUADS>;\n        var val = 0.0;\n        var qp0 = p0;\n        let step = 1.0 / f32(n_quads);\n        for (var i = 0u; i < n_quads; i += 1u) {\n            let t = f32(i + 1u) * step;\n            let qp2 = eval_cubic(p0, p1, p2, p3, t);\n            var qp1 = eval_cubic(p0, p1, p2, p3, t - 0.5 * step);\n            qp1 = 2.0 * qp1 - 0.5 * (qp0 + qp2);\n            let params = estimate_subdiv(qp0, qp1, qp2, sqrt(REM_ACCURACY));\n            keep_params[i] = params;\n            val += params.val;\n            qp0 = qp2;\n        }\n        let n = max(u32(ceil(val * (0.5 / sqrt(REM_ACCURACY)))), 1u);\n        var lp0 = p0;\n        qp0 = p0;\n        let v_step = val / f32(n);\n        var n_out = 1u;\n        var val_sum = 0.0;\n        for (var i = 0u; i < n_quads; i += 1u) {\n            let t = f32(i + 1u) * step;\n            let qp2 = eval_cubic(p0, p1, p2, p3, t);\n            var qp1 = eval_cubic(p0, p1, p2, p3, t - 0.5 * step);\n            qp1 = 2.0 * qp1 - 0.5 * (qp0 + qp2);\n            let params = keep_params[i];\n            let u0 = approx_parabola_inv_integral(params.a0);\n            let u2 = approx_parabola_inv_integral(params.a2);\n            let uscale = 1.0 / (u2 - u0);\n            var val_target = f32(n_out) * v_step;\n            while n_out == n || val_target < val_sum + params.val {\n                var lp1: vec2<f32>;\n                if n_out == n {\n                    lp1 = p3;\n                } else {\n                    let u = (val_target - val_sum) / params.val;\n                    let a = mix(params.a0, params.a2, u);\n                    let au = approx_parabola_inv_integral(a);\n                    let t = (au - u0) * uscale;\n                    lp1 = eval_quad(qp0, qp1, qp2, t);\n                }\n\n                // Output line segment lp0..lp1\n                let xymin = min(lp0, lp1) - cubic.stroke;\n                let xymax = max(lp0, lp1) + cubic.stroke;\n                let dp = lp1 - lp0;\n                let recip_dx = 1.0 / dp.x;\n                let invslope = select(dp.x / dp.y, 1.0e9, abs(dp.y) < 1.0e-9);\n                let SX = 1.0 / f32(TILE_WIDTH);\n                let SY = 1.0 / f32(TILE_HEIGHT);\n                let c = (cubic.stroke.x + abs(invslope) * (0.5 * f32(TILE_HEIGHT) + cubic.stroke.y)) * SX;\n                let b = invslope;\n                let a = (lp0.x - (lp0.y - 0.5 * f32(TILE_HEIGHT)) * b) * SX;\n                var x0 = i32(floor(xymin.x * SX));\n                var x1 = i32(floor(xymax.x * SX) + 1.0);\n                var y0 = i32(floor(xymin.y * SY));\n                var y1 = i32(floor(xymax.y * SY) + 1.0);\n                x0 = clamp(x0, bbox.x, bbox.z);\n                x1 = clamp(x1, bbox.x, bbox.z);\n                y0 = clamp(y0, bbox.y, bbox.w);\n                y1 = clamp(y1, bbox.y, bbox.w);\n                var xc = a + b * f32(y0);\n                let stride = bbox.z - bbox.x;\n                var base = i32(path.tiles) + (y0 - bbox.y) * stride - bbox.x;\n                var xray = i32(floor(lp0.x * SX));\n                var last_xray = i32(floor(lp1.x * SX));\n                if dp.y < 0.0 {\n                    let tmp = xray;\n                    xray = last_xray;\n                    last_xray = tmp;\n                }\n                for (var y = y0; y < y1; y += 1) {\n                    let tile_y0 = f32(y) * f32(TILE_HEIGHT);\n                    let xbackdrop = max(xray + 1, bbox.x);\n                    if !is_stroke && xymin.y < tile_y0 && xbackdrop < bbox.z {\n                        let backdrop = select(-1, 1, dp.y < 0.0);\n                        let tile_ix = base + xbackdrop;\n                        atomicAdd(&tiles[tile_ix].backdrop, backdrop);\n                    }\n                    var next_xray = last_xray;\n                    if y + 1 < y1 {\n                        let tile_y1 = f32(y + 1) * f32(TILE_HEIGHT);\n                        let x_edge = lp0.x + (tile_y1 - lp0.y) * invslope;\n                        next_xray = i32(floor(x_edge * SX));\n                    }\n                    let min_xray = min(xray, next_xray);\n                    let max_xray = max(xray, next_xray);\n                    var xx0 = min(i32(floor(xc - c)), min_xray);\n                    var xx1 = max(i32(ceil(xc + c)), max_xray + 1);\n                    xx0 = clamp(xx0, x0, x1);\n                    xx1 = clamp(xx1, x0, x1);\n                    var tile_seg: Segment;\n                    for (var x = xx0; x < xx1; x += 1) {\n                        let tile_x0 = f32(x) * f32(TILE_WIDTH);\n                        let tile_ix = base + x;\n                        // allocate segment, insert linked list\n                        let seg_ix = alloc_segment();\n                        let old = atomicExchange(&tiles[tile_ix].segments, seg_ix);\n                        tile_seg.origin = lp0;\n                        tile_seg.delta = dp;\n                        var y_edge = 0.0;\n                        if !is_stroke {\n                            y_edge = mix(lp0.y, lp1.y, (tile_x0 - lp0.x) * recip_dx);\n                            if xymin.x < tile_x0 {\n                                let p = vec2(tile_x0, y_edge);\n                                if dp.x < 0.0 {\n                                    tile_seg.delta = p - lp0;\n                                } else {\n                                    tile_seg.origin = p;\n                                    tile_seg.delta = lp1 - p;\n                                }\n                                if tile_seg.delta.x == 0.0 {\n                                    tile_seg.delta.x = sign(dp.x) * 1e-9;\n                                }\n                            }\n                            if x <= min_xray || max_xray < x {\n                                y_edge = 1e9;\n                            }\n                        }\n                        tile_seg.y_edge = y_edge;\n                        tile_seg.next = old;\n                        segments[seg_ix] = tile_seg;\n                    }\n                    xc += b;\n                    base += stride;\n                    xray = next_xray;\n                }\n                n_out += 1u;\n                val_target += v_step;\n                lp0 = lp1;\n            }\n            val_sum += params.val;\n            qp0 = qp2;\n        }\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    // TODO: Also seems incorrect
    // bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer', 'Buffer' ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer', 'Buffer' ],
    workgroup_buffers: []
  },
  pathseg: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Path segment decoding for the full case.\n\n// In the simple case, path segments are decoded as part of the coarse\n// path rendering stage. In the full case, they are separated, as the\n// decoding process also generates bounding boxes, and those in turn are\n// used for tile allocation and clipping; actual coarse path rasterization\n// can't proceed until those are complete.\n\n// There's some duplication of the decoding code but we won't worry about\n// that just now. Perhaps it could be factored more nicely later.\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct TagMonoid {\n    trans_ix: u32,\n    // TODO: I don't think pathseg_ix is used.\n    pathseg_ix: u32,\n    pathseg_offset: u32,\n    linewidth_ix: u32,\n    path_ix: u32,\n}\n\nconst PATH_TAG_SEG_TYPE = 3u;\nconst PATH_TAG_LINETO = 1u;\nconst PATH_TAG_QUADTO = 2u;\nconst PATH_TAG_CUBICTO = 3u;\nconst PATH_TAG_F32 = 8u;\nconst PATH_TAG_TRANSFORM = 0x20u;\nconst PATH_TAG_PATH = 0x10u;\nconst PATH_TAG_LINEWIDTH = 0x40u;\n\nfn tag_monoid_identity() -> TagMonoid {\n    return TagMonoid();\n}\n\nfn combine_tag_monoid(a: TagMonoid, b: TagMonoid) -> TagMonoid {\n    var c: TagMonoid;\n    c.trans_ix = a.trans_ix + b.trans_ix;\n    c.pathseg_ix = a.pathseg_ix + b.pathseg_ix;\n    c.pathseg_offset = a.pathseg_offset + b.pathseg_offset;\n    c.linewidth_ix = a.linewidth_ix + b.linewidth_ix;\n    c.path_ix = a.path_ix + b.path_ix;\n    return c;\n}\n\nfn reduce_tag(tag_word: u32) -> TagMonoid {\n    var c: TagMonoid;\n    let point_count = tag_word & 0x3030303u;\n    c.pathseg_ix = countOneBits((point_count * 7u) & 0x4040404u);\n    c.trans_ix = countOneBits(tag_word & (PATH_TAG_TRANSFORM * 0x1010101u));\n    let n_points = point_count + ((tag_word >> 2u) & 0x1010101u);\n    var a = n_points + (n_points & (((tag_word >> 3u) & 0x1010101u) * 15u));\n    a += a >> 8u;\n    a += a >> 16u;\n    c.pathseg_offset = a & 0xffu;\n    c.path_ix = countOneBits(tag_word & (PATH_TAG_PATH * 0x1010101u));\n    c.linewidth_ix = countOneBits(tag_word & (PATH_TAG_LINEWIDTH * 0x1010101u));\n    return c;\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct Cubic {\n    p0: vec2<f32>,\n    p1: vec2<f32>,\n    p2: vec2<f32>,\n    p3: vec2<f32>,\n    stroke: vec2<f32>,\n    path_ix: u32,\n    flags: u32,\n}\n\nconst CUBIC_IS_STROKE = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Helpers for working with transforms.\n\nstruct Transform {\n    matrx: vec4<f32>,\n    translate: vec2<f32>,\n}\n\nfn transform_apply(transform: Transform, p: vec2<f32>) -> vec2<f32> {\n    return transform.matrx.xy * p.x + transform.matrx.zw * p.y + transform.translate;\n}\n\nfn transform_inverse(transform: Transform) -> Transform {\n    let inv_det = 1.0 / (transform.matrx.x * transform.matrx.w - transform.matrx.y * transform.matrx.z);\n    let inv_mat = inv_det * vec4(transform.matrx.w, -transform.matrx.y, -transform.matrx.z, transform.matrx.x);\n    let inv_tr = mat2x2(inv_mat.xy, inv_mat.zw) * -transform.translate;\n    return Transform(inv_mat, inv_tr);\n}\n\nfn transform_mul(a: Transform, b: Transform) -> Transform {\n    return Transform(\n        a.matrx.xyxy * b.matrx.xxzz + a.matrx.zwzw * b.matrx.yyww,\n        a.matrx.xy * b.translate.x + a.matrx.zw * b.translate.y + a.translate\n    );\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage> tag_monoids: array<TagMonoid>;\n\nstruct AtomicPathBbox {\n    x0: atomic<i32>,\n    y0: atomic<i32>,\n    x1: atomic<i32>,\n    y1: atomic<i32>,\n    linewidth: f32,\n    trans_ix: u32,\n}\n\n@group(0) @binding(3)\nvar<storage, read_write> path_bboxes: array<AtomicPathBbox>;\n\n@group(0) @binding(4)\nvar<storage, read_write> cubics: array<Cubic>;\n\n// Monoid is yagni, for future optimization\n\n// struct BboxMonoid {\n//     bbox: vec4<f32>,\n//     flags: u32,\n// }\n\n// let FLAG_RESET_BBOX = 1u;\n// let FLAG_SET_BBOX = 2u;\n\n// fn combine_bbox_monoid(a: BboxMonoid, b: BboxMonoid) -> BboxMonoid {\n//     var c: BboxMonoid;\n//     c.bbox = b.bbox;\n//     // TODO: previous-me thought this should be gated on b & SET_BBOX == false also\n//     if (a.flags & FLAG_RESET_BBOX) == 0u && b.bbox.z <= b.bbox.x && b.bbox.w <= b.bbox.y {\n//         c.bbox = a.bbox;\n//     } else if (a.flags & FLAG_RESET_BBOX) == 0u && (b.flags & FLAG_SET_BBOX) == 0u ||\n//         (a.bbox.z > a.bbox.x || a.bbox.w > a.bbox.y)\n//     {\n//         c.bbox = vec4<f32>(min(a.bbox.xy, c.bbox.xy), max(a.bbox.xw, c.bbox.zw));\n//     }\n//     c.flags = (a.flags & FLAG_SET_BBOX) | b.flags;\n//     c.flags |= (a.flags & FLAG_RESET_BBOX) << 1u;\n//     return c;\n// }\n\n// fn bbox_monoid_identity() -> BboxMonoid {\n//     return BboxMonoid();\n// }\n\nvar<private> pathdata_base: u32;\n\nfn read_f32_point(ix: u32) -> vec2<f32> {\n    let x = bitcast<f32>(scene[pathdata_base + ix]);\n    let y = bitcast<f32>(scene[pathdata_base + ix + 1u]);\n    return vec2(x, y);\n}\n\nfn read_i16_point(ix: u32) -> vec2<f32> {\n    let raw = scene[pathdata_base + ix];\n    let x = f32(i32(raw << 16u) >> 16u);\n    let y = f32(i32(raw) >> 16u);\n    return vec2(x, y);\n}\n\nfn read_transform(transform_base: u32, ix: u32) -> Transform {\n    let base = transform_base + ix * 6u;\n    let c0 = bitcast<f32>(scene[base]);\n    let c1 = bitcast<f32>(scene[base + 1u]);\n    let c2 = bitcast<f32>(scene[base + 2u]);\n    let c3 = bitcast<f32>(scene[base + 3u]);\n    let c4 = bitcast<f32>(scene[base + 4u]);\n    let c5 = bitcast<f32>(scene[base + 5u]);\n    let matrx = vec4(c0, c1, c2, c3);\n    let translate = vec2(c4, c5);\n    return Transform(matrx, translate);\n}\n\nfn round_down(x: f32) -> i32 {\n    return i32(floor(x));\n}\n\nfn round_up(x: f32) -> i32 {\n    return i32(ceil(x));\n}\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n) {\n    let ix = global_id.x;\n    let tag_word = scene[config.pathtag_base + (ix >> 2u)];\n    pathdata_base = config.pathdata_base;\n    let shift = (ix & 3u) * 8u;\n    var tm = reduce_tag(tag_word & ((1u << shift) - 1u));\n    tm = combine_tag_monoid(tag_monoids[ix >> 2u], tm);\n    var tag_byte = (tag_word >> shift) & 0xffu;\n\n    let out = &path_bboxes[tm.path_ix];\n    let linewidth = bitcast<f32>(scene[config.linewidth_base + tm.linewidth_ix]);\n    if (tag_byte & PATH_TAG_PATH) != 0u {\n        (*out).linewidth = linewidth;\n        (*out).trans_ix = tm.trans_ix;\n    }\n    // Decode path data\n    let seg_type = tag_byte & PATH_TAG_SEG_TYPE;\n    if seg_type != 0u {\n        var p0: vec2<f32>;\n        var p1: vec2<f32>;\n        var p2: vec2<f32>;\n        var p3: vec2<f32>;\n        if (tag_byte & PATH_TAG_F32) != 0u {\n            p0 = read_f32_point(tm.pathseg_offset);\n            p1 = read_f32_point(tm.pathseg_offset + 2u);\n            if seg_type >= PATH_TAG_QUADTO {\n                p2 = read_f32_point(tm.pathseg_offset + 4u);\n                if seg_type == PATH_TAG_CUBICTO {\n                    p3 = read_f32_point(tm.pathseg_offset + 6u);\n                }\n            }\n        } else {\n            p0 = read_i16_point(tm.pathseg_offset);\n            p1 = read_i16_point(tm.pathseg_offset + 1u);\n            if seg_type >= PATH_TAG_QUADTO {\n                p2 = read_i16_point(tm.pathseg_offset + 2u);\n                if seg_type == PATH_TAG_CUBICTO {\n                    p3 = read_i16_point(tm.pathseg_offset + 3u);\n                }\n            }\n        }\n        let transform = read_transform(config.transform_base, tm.trans_ix);\n        p0 = transform_apply(transform, p0);\n        p1 = transform_apply(transform, p1);\n        var bbox = vec4(min(p0, p1), max(p0, p1));\n        // Degree-raise\n        if seg_type == PATH_TAG_LINETO {\n            p3 = p1;\n            p2 = mix(p3, p0, 1.0 / 3.0);\n            p1 = mix(p0, p3, 1.0 / 3.0);\n        } else if seg_type >= PATH_TAG_QUADTO {\n            p2 = transform_apply(transform, p2);\n            bbox = vec4(min(bbox.xy, p2), max(bbox.zw, p2));\n            if seg_type == PATH_TAG_CUBICTO {\n                p3 = transform_apply(transform, p3);\n                bbox = vec4(min(bbox.xy, p3), max(bbox.zw, p3));\n            } else {\n                p3 = p2;\n                p2 = mix(p1, p2, 1.0 / 3.0);\n                p1 = mix(p1, p0, 1.0 / 3.0);\n            }\n        }\n        var stroke = vec2(0.0, 0.0);\n        if linewidth >= 0.0 {\n            // See https://www.iquilezles.org/www/articles/ellipses/ellipses.htm\n            // This is the correct bounding box, but we're not handling rendering\n            // in the isotropic case, so it may mismatch.\n            stroke = 0.5 * linewidth * vec2(length(transform.matrx.xz), length(transform.matrx.yw));\n            bbox += vec4(-stroke, stroke);\n        }\n        let flags = u32(linewidth >= 0.0);\n        cubics[global_id.x] = Cubic(p0, p1, p2, p3, stroke, tm.path_ix, flags);\n        // Update bounding box using atomics only. Computing a monoid is a\n        // potential future optimization.\n        if bbox.z > bbox.x || bbox.w > bbox.y {\n            atomicMin(&(*out).x0, round_down(bbox.x));\n            atomicMin(&(*out).y0, round_down(bbox.y));\n            atomicMax(&(*out).x1, round_up(bbox.z));\n            atomicMax(&(*out).y1, round_up(bbox.w));\n        }\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
    workgroup_buffers: []
  },
  pathtag_reduce: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct TagMonoid {\n    trans_ix: u32,\n    // TODO: I don't think pathseg_ix is used.\n    pathseg_ix: u32,\n    pathseg_offset: u32,\n    linewidth_ix: u32,\n    path_ix: u32,\n}\n\nconst PATH_TAG_SEG_TYPE = 3u;\nconst PATH_TAG_LINETO = 1u;\nconst PATH_TAG_QUADTO = 2u;\nconst PATH_TAG_CUBICTO = 3u;\nconst PATH_TAG_F32 = 8u;\nconst PATH_TAG_TRANSFORM = 0x20u;\nconst PATH_TAG_PATH = 0x10u;\nconst PATH_TAG_LINEWIDTH = 0x40u;\n\nfn tag_monoid_identity() -> TagMonoid {\n    return TagMonoid();\n}\n\nfn combine_tag_monoid(a: TagMonoid, b: TagMonoid) -> TagMonoid {\n    var c: TagMonoid;\n    c.trans_ix = a.trans_ix + b.trans_ix;\n    c.pathseg_ix = a.pathseg_ix + b.pathseg_ix;\n    c.pathseg_offset = a.pathseg_offset + b.pathseg_offset;\n    c.linewidth_ix = a.linewidth_ix + b.linewidth_ix;\n    c.path_ix = a.path_ix + b.path_ix;\n    return c;\n}\n\nfn reduce_tag(tag_word: u32) -> TagMonoid {\n    var c: TagMonoid;\n    let point_count = tag_word & 0x3030303u;\n    c.pathseg_ix = countOneBits((point_count * 7u) & 0x4040404u);\n    c.trans_ix = countOneBits(tag_word & (PATH_TAG_TRANSFORM * 0x1010101u));\n    let n_points = point_count + ((tag_word >> 2u) & 0x1010101u);\n    var a = n_points + (n_points & (((tag_word >> 3u) & 0x1010101u) * 15u));\n    a += a >> 8u;\n    a += a >> 16u;\n    c.pathseg_offset = a & 0xffu;\n    c.path_ix = countOneBits(tag_word & (PATH_TAG_PATH * 0x1010101u));\n    c.linewidth_ix = countOneBits(tag_word & (PATH_TAG_LINEWIDTH * 0x1010101u));\n    return c;\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> reduced: array<TagMonoid>;\n\nconst LG_WG_SIZE = 8u;\nconst WG_SIZE = 256u;\n\nvar<workgroup> sh_scratch: array<TagMonoid, WG_SIZE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n) {\n    let ix = global_id.x;\n    let tag_word = scene[config.pathtag_base + ix];\n    var agg = reduce_tag(tag_word);\n    sh_scratch[local_id.x] = agg;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x + (1u << i) < WG_SIZE {\n            let other = sh_scratch[local_id.x + (1u << i)];\n            agg = combine_tag_monoid(agg, other);\n        }\n        workgroupBarrier();\n        sh_scratch[local_id.x] = agg;\n    }\n    if local_id.x == 0u {\n        reduced[ix >> LG_WG_SIZE] = agg;\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 5120, index: 0 }
    ]
  },
  pathtag_reduce2: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This shader is the second stage of reduction for the pathtag\n// monoid scan, needed when the number of tags is large.\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct TagMonoid {\n    trans_ix: u32,\n    // TODO: I don't think pathseg_ix is used.\n    pathseg_ix: u32,\n    pathseg_offset: u32,\n    linewidth_ix: u32,\n    path_ix: u32,\n}\n\nconst PATH_TAG_SEG_TYPE = 3u;\nconst PATH_TAG_LINETO = 1u;\nconst PATH_TAG_QUADTO = 2u;\nconst PATH_TAG_CUBICTO = 3u;\nconst PATH_TAG_F32 = 8u;\nconst PATH_TAG_TRANSFORM = 0x20u;\nconst PATH_TAG_PATH = 0x10u;\nconst PATH_TAG_LINEWIDTH = 0x40u;\n\nfn tag_monoid_identity() -> TagMonoid {\n    return TagMonoid();\n}\n\nfn combine_tag_monoid(a: TagMonoid, b: TagMonoid) -> TagMonoid {\n    var c: TagMonoid;\n    c.trans_ix = a.trans_ix + b.trans_ix;\n    c.pathseg_ix = a.pathseg_ix + b.pathseg_ix;\n    c.pathseg_offset = a.pathseg_offset + b.pathseg_offset;\n    c.linewidth_ix = a.linewidth_ix + b.linewidth_ix;\n    c.path_ix = a.path_ix + b.path_ix;\n    return c;\n}\n\nfn reduce_tag(tag_word: u32) -> TagMonoid {\n    var c: TagMonoid;\n    let point_count = tag_word & 0x3030303u;\n    c.pathseg_ix = countOneBits((point_count * 7u) & 0x4040404u);\n    c.trans_ix = countOneBits(tag_word & (PATH_TAG_TRANSFORM * 0x1010101u));\n    let n_points = point_count + ((tag_word >> 2u) & 0x1010101u);\n    var a = n_points + (n_points & (((tag_word >> 3u) & 0x1010101u) * 15u));\n    a += a >> 8u;\n    a += a >> 16u;\n    c.pathseg_offset = a & 0xffu;\n    c.path_ix = countOneBits(tag_word & (PATH_TAG_PATH * 0x1010101u));\n    c.linewidth_ix = countOneBits(tag_word & (PATH_TAG_LINEWIDTH * 0x1010101u));\n    return c;\n}\n\n\n@group(0) @binding(0)\nvar<storage> reduced_in: array<TagMonoid>;\n\n@group(0) @binding(1)\nvar<storage, read_write> reduced: array<TagMonoid>;\n\nconst LG_WG_SIZE = 8u;\nconst WG_SIZE = 256u;\n\nvar<workgroup> sh_scratch: array<TagMonoid, WG_SIZE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n) {\n    let ix = global_id.x;\n    var agg = reduced_in[ix];\n    sh_scratch[local_id.x] = agg;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x + (1u << i) < WG_SIZE {\n            let other = sh_scratch[local_id.x + (1u << i)];\n            agg = combine_tag_monoid(agg, other);\n        }\n        workgroupBarrier();\n        sh_scratch[local_id.x] = agg;\n    }\n    if local_id.x == 0u {\n        reduced[ix >> LG_WG_SIZE] = agg;\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'BufReadOnly', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 5120, index: 0 }
    ]
  },
  pathtag_scan1: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This shader computes the scan of reduced tag monoids given\n// two levels of reduction.\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct TagMonoid {\n    trans_ix: u32,\n    // TODO: I don't think pathseg_ix is used.\n    pathseg_ix: u32,\n    pathseg_offset: u32,\n    linewidth_ix: u32,\n    path_ix: u32,\n}\n\nconst PATH_TAG_SEG_TYPE = 3u;\nconst PATH_TAG_LINETO = 1u;\nconst PATH_TAG_QUADTO = 2u;\nconst PATH_TAG_CUBICTO = 3u;\nconst PATH_TAG_F32 = 8u;\nconst PATH_TAG_TRANSFORM = 0x20u;\nconst PATH_TAG_PATH = 0x10u;\nconst PATH_TAG_LINEWIDTH = 0x40u;\n\nfn tag_monoid_identity() -> TagMonoid {\n    return TagMonoid();\n}\n\nfn combine_tag_monoid(a: TagMonoid, b: TagMonoid) -> TagMonoid {\n    var c: TagMonoid;\n    c.trans_ix = a.trans_ix + b.trans_ix;\n    c.pathseg_ix = a.pathseg_ix + b.pathseg_ix;\n    c.pathseg_offset = a.pathseg_offset + b.pathseg_offset;\n    c.linewidth_ix = a.linewidth_ix + b.linewidth_ix;\n    c.path_ix = a.path_ix + b.path_ix;\n    return c;\n}\n\nfn reduce_tag(tag_word: u32) -> TagMonoid {\n    var c: TagMonoid;\n    let point_count = tag_word & 0x3030303u;\n    c.pathseg_ix = countOneBits((point_count * 7u) & 0x4040404u);\n    c.trans_ix = countOneBits(tag_word & (PATH_TAG_TRANSFORM * 0x1010101u));\n    let n_points = point_count + ((tag_word >> 2u) & 0x1010101u);\n    var a = n_points + (n_points & (((tag_word >> 3u) & 0x1010101u) * 15u));\n    a += a >> 8u;\n    a += a >> 16u;\n    c.pathseg_offset = a & 0xffu;\n    c.path_ix = countOneBits(tag_word & (PATH_TAG_PATH * 0x1010101u));\n    c.linewidth_ix = countOneBits(tag_word & (PATH_TAG_LINEWIDTH * 0x1010101u));\n    return c;\n}\n\n\n@group(0) @binding(0)\nvar<storage> reduced: array<TagMonoid>;\n\n@group(0) @binding(1)\nvar<storage> reduced2: array<TagMonoid>;\n\n@group(0) @binding(2)\nvar<storage, read_write> tag_monoids: array<TagMonoid>;\n\nconst LG_WG_SIZE = 8u;\nconst WG_SIZE = 256u;\n\nvar<workgroup> sh_parent: array<TagMonoid, WG_SIZE>;\n// These could be combined?\nvar<workgroup> sh_monoid: array<TagMonoid, WG_SIZE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n    var agg = tag_monoid_identity();\n    if local_id.x < wg_id.x {\n        agg = reduced2[local_id.x];\n    }\n    sh_parent[local_id.x] = agg;\n    for (var i = 0u; i < LG_WG_SIZE; i += 1u) {\n        workgroupBarrier();\n        if local_id.x + (1u << i) < WG_SIZE {\n            let other = sh_parent[local_id.x + (1u << i)];\n            agg = combine_tag_monoid(agg, other);\n        }\n        workgroupBarrier();\n        sh_parent[local_id.x] = agg;\n    }\n\n    let ix = global_id.x;\n    agg = reduced[ix];\n    sh_monoid[local_id.x] = agg;\n    for (var i = 0u; i < LG_WG_SIZE; i += 1u) {\n        workgroupBarrier();\n        if local_id.x >= 1u << i {\n            let other = sh_monoid[local_id.x - (1u << i)];\n            agg = combine_tag_monoid(other, agg);\n        }\n        workgroupBarrier();\n        sh_monoid[local_id.x] = agg;\n    }\n    workgroupBarrier();\n    // prefix up to this workgroup\n    var tm = sh_parent[0];\n    if local_id.x > 0u {\n        tm = combine_tag_monoid(tm, sh_monoid[local_id.x - 1u]);\n    }\n    // exclusive prefix sum, granularity of 4 tag bytes * workgroup size\n    tag_monoids[ix] = tm;\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'BufReadOnly', 'BufReadOnly', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 5120, index: 0 },
      { size_in_bytes: 5120, index: 1 }
    ]
  },
  pathtag_scan_large: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct TagMonoid {\n    trans_ix: u32,\n    // TODO: I don't think pathseg_ix is used.\n    pathseg_ix: u32,\n    pathseg_offset: u32,\n    linewidth_ix: u32,\n    path_ix: u32,\n}\n\nconst PATH_TAG_SEG_TYPE = 3u;\nconst PATH_TAG_LINETO = 1u;\nconst PATH_TAG_QUADTO = 2u;\nconst PATH_TAG_CUBICTO = 3u;\nconst PATH_TAG_F32 = 8u;\nconst PATH_TAG_TRANSFORM = 0x20u;\nconst PATH_TAG_PATH = 0x10u;\nconst PATH_TAG_LINEWIDTH = 0x40u;\n\nfn tag_monoid_identity() -> TagMonoid {\n    return TagMonoid();\n}\n\nfn combine_tag_monoid(a: TagMonoid, b: TagMonoid) -> TagMonoid {\n    var c: TagMonoid;\n    c.trans_ix = a.trans_ix + b.trans_ix;\n    c.pathseg_ix = a.pathseg_ix + b.pathseg_ix;\n    c.pathseg_offset = a.pathseg_offset + b.pathseg_offset;\n    c.linewidth_ix = a.linewidth_ix + b.linewidth_ix;\n    c.path_ix = a.path_ix + b.path_ix;\n    return c;\n}\n\nfn reduce_tag(tag_word: u32) -> TagMonoid {\n    var c: TagMonoid;\n    let point_count = tag_word & 0x3030303u;\n    c.pathseg_ix = countOneBits((point_count * 7u) & 0x4040404u);\n    c.trans_ix = countOneBits(tag_word & (PATH_TAG_TRANSFORM * 0x1010101u));\n    let n_points = point_count + ((tag_word >> 2u) & 0x1010101u);\n    var a = n_points + (n_points & (((tag_word >> 3u) & 0x1010101u) * 15u));\n    a += a >> 8u;\n    a += a >> 16u;\n    c.pathseg_offset = a & 0xffu;\n    c.path_ix = countOneBits(tag_word & (PATH_TAG_PATH * 0x1010101u));\n    c.linewidth_ix = countOneBits(tag_word & (PATH_TAG_LINEWIDTH * 0x1010101u));\n    return c;\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage> reduced: array<TagMonoid>;\n\n@group(0) @binding(3)\nvar<storage, read_write> tag_monoids: array<TagMonoid>;\n\nconst LG_WG_SIZE = 8u;\nconst WG_SIZE = 256u;\n\n// These could be combined?\nvar<workgroup> sh_monoid: array<TagMonoid, WG_SIZE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n\n    let ix = global_id.x;\n    let tag_word = scene[config.pathtag_base + ix];\n    var agg_part = reduce_tag(tag_word);\n    sh_monoid[local_id.x] = agg_part;\n    for (var i = 0u; i < LG_WG_SIZE; i += 1u) {\n        workgroupBarrier();\n        if local_id.x >= 1u << i {\n            let other = sh_monoid[local_id.x - (1u << i)];\n            agg_part = combine_tag_monoid(other, agg_part);\n        }\n        workgroupBarrier();\n        sh_monoid[local_id.x] = agg_part;\n    }\n    workgroupBarrier();\n    // prefix up to this workgroup\n    var tm = reduced[wg_id.x];\n    if local_id.x > 0u {\n        tm = combine_tag_monoid(tm, sh_monoid[local_id.x - 1u]);\n    }\n    // exclusive prefix sum, granularity of 4 tag bytes\n    tag_monoids[ix] = tm;\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 5120, index: 0 }
    ]
  },
  pathtag_scan_small: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\nstruct TagMonoid {\n    trans_ix: u32,\n    // TODO: I don't think pathseg_ix is used.\n    pathseg_ix: u32,\n    pathseg_offset: u32,\n    linewidth_ix: u32,\n    path_ix: u32,\n}\n\nconst PATH_TAG_SEG_TYPE = 3u;\nconst PATH_TAG_LINETO = 1u;\nconst PATH_TAG_QUADTO = 2u;\nconst PATH_TAG_CUBICTO = 3u;\nconst PATH_TAG_F32 = 8u;\nconst PATH_TAG_TRANSFORM = 0x20u;\nconst PATH_TAG_PATH = 0x10u;\nconst PATH_TAG_LINEWIDTH = 0x40u;\n\nfn tag_monoid_identity() -> TagMonoid {\n    return TagMonoid();\n}\n\nfn combine_tag_monoid(a: TagMonoid, b: TagMonoid) -> TagMonoid {\n    var c: TagMonoid;\n    c.trans_ix = a.trans_ix + b.trans_ix;\n    c.pathseg_ix = a.pathseg_ix + b.pathseg_ix;\n    c.pathseg_offset = a.pathseg_offset + b.pathseg_offset;\n    c.linewidth_ix = a.linewidth_ix + b.linewidth_ix;\n    c.path_ix = a.path_ix + b.path_ix;\n    return c;\n}\n\nfn reduce_tag(tag_word: u32) -> TagMonoid {\n    var c: TagMonoid;\n    let point_count = tag_word & 0x3030303u;\n    c.pathseg_ix = countOneBits((point_count * 7u) & 0x4040404u);\n    c.trans_ix = countOneBits(tag_word & (PATH_TAG_TRANSFORM * 0x1010101u));\n    let n_points = point_count + ((tag_word >> 2u) & 0x1010101u);\n    var a = n_points + (n_points & (((tag_word >> 3u) & 0x1010101u) * 15u));\n    a += a >> 8u;\n    a += a >> 16u;\n    c.pathseg_offset = a & 0xffu;\n    c.path_ix = countOneBits(tag_word & (PATH_TAG_PATH * 0x1010101u));\n    c.linewidth_ix = countOneBits(tag_word & (PATH_TAG_LINEWIDTH * 0x1010101u));\n    return c;\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage> reduced: array<TagMonoid>;\n\n@group(0) @binding(3)\nvar<storage, read_write> tag_monoids: array<TagMonoid>;\n\nconst LG_WG_SIZE = 8u;\nconst WG_SIZE = 256u;\n\nvar<workgroup> sh_parent: array<TagMonoid, WG_SIZE>;\n// These could be combined?\nvar<workgroup> sh_monoid: array<TagMonoid, WG_SIZE>;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n    @builtin(workgroup_id) wg_id: vec3<u32>,\n) {\n    var agg = tag_monoid_identity();\n    if local_id.x < wg_id.x {\n        agg = reduced[local_id.x];\n    }\n    sh_parent[local_id.x] = agg;\n    for (var i = 0u; i < LG_WG_SIZE; i += 1u) {\n        workgroupBarrier();\n        if local_id.x + (1u << i) < WG_SIZE {\n            let other = sh_parent[local_id.x + (1u << i)];\n            agg = combine_tag_monoid(agg, other);\n        }\n        workgroupBarrier();\n        sh_parent[local_id.x] = agg;\n    }\n\n    let ix = global_id.x;\n    let tag_word = scene[config.pathtag_base + ix];\n    var agg_part = reduce_tag(tag_word);\n    sh_monoid[local_id.x] = agg_part;\n    for (var i = 0u; i < LG_WG_SIZE; i += 1u) {\n        workgroupBarrier();\n        if local_id.x >= 1u << i {\n            let other = sh_monoid[local_id.x - (1u << i)];\n            agg_part = combine_tag_monoid(other, agg_part);\n        }\n        workgroupBarrier();\n        sh_monoid[local_id.x] = agg_part;\n    }\n    workgroupBarrier();\n    // prefix up to this workgroup\n    var tm = sh_parent[0];\n    if local_id.x > 0u {\n        tm = combine_tag_monoid(tm, sh_monoid[local_id.x - 1u]);\n    }\n    // exclusive prefix sum, granularity of 4 tag bytes\n    tag_monoids[ix] = tm;\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 5120, index: 0 },
      { size_in_bytes: 5120, index: 1 }
    ]
  },
  tile_alloc: {
    wgsl: "// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Tile allocation (and zeroing of tiles)\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// This must be kept in sync with the struct in src/encoding/resolve.rs\nstruct Config {\n    width_in_tiles: u32,\n    height_in_tiles: u32,\n\n    target_width: u32,\n    target_height: u32,\n\n    // The initial color applied to the pixels in a tile during the fine stage.\n    // This is only used in the full pipeline. The format is packed RGBA8 in MSB\n    // order.\n    base_color: u32,\n\n    n_drawobj: u32,\n    n_path: u32,\n    n_clip: u32,\n\n    // To reduce the number of bindings, info and bin data are combined\n    // into one buffer.\n    bin_data_start: u32,\n\n    // offsets within scene buffer (in u32 units)\n    pathtag_base: u32,\n    pathdata_base: u32,\n\n    drawtag_base: u32,\n    drawdata_base: u32,\n\n    transform_base: u32,\n    linewidth_base: u32,\n\n    // Sizes of bump allocated buffers (in element size units)\n    binning_size: u32,\n    tiles_size: u32,\n    segments_size: u32,    \n    ptcl_size: u32,\n}\n\n// Geometry of tiles and bins\n\nconst TILE_WIDTH = 16u;\nconst TILE_HEIGHT = 16u;\n// Number of tiles per bin\nconst N_TILE_X = 16u;\nconst N_TILE_Y = 16u;\n//let N_TILE = N_TILE_X * N_TILE_Y;\nconst N_TILE = 256u;\n\nconst BLEND_STACK_SPLIT = 4u;\n\n// The following are computed in draw_leaf from the generic gradient parameters\n// encoded in the scene, and stored in the gradient's info struct, for\n// consumption during fine rasterization.\n\n// Radial gradient kinds\nconst RAD_GRAD_KIND_CIRCULAR = 1u;\nconst RAD_GRAD_KIND_STRIP = 2u;\nconst RAD_GRAD_KIND_FOCAL_ON_CIRCLE = 3u;\nconst RAD_GRAD_KIND_CONE = 4u;\n\n// Radial gradient flags\nconst RAD_GRAD_SWAPPED = 1u;\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Bitflags for each stage that can fail allocation.\nconst STAGE_BINNING: u32 = 0x1u;\nconst STAGE_TILE_ALLOC: u32 = 0x2u;\nconst STAGE_PATH_COARSE: u32 = 0x4u;\nconst STAGE_COARSE: u32 = 0x8u;\n\n// This must be kept in sync with the struct in src/render.rs\nstruct BumpAllocators {\n    // Bitmask of stages that have failed allocation.\n    failed: atomic<u32>,\n    binning: atomic<u32>,\n    ptcl: atomic<u32>,\n    tile: atomic<u32>,\n    segments: atomic<u32>,\n    blend: atomic<u32>,\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// The DrawMonoid is computed as a prefix sum to aid in decoding\n// the variable-length encoding of draw objects.\nstruct DrawMonoid {\n    // The number of paths preceding this draw object.\n    path_ix: u32,\n    // The number of clip operations preceding this draw object.\n    clip_ix: u32,\n    // The offset of the encoded draw object in the scene (u32s).\n    scene_offset: u32,\n    // The offset of the associated info.\n    info_offset: u32,\n}\n\n// Each draw object has a 32-bit draw tag, which is a bit-packed\n// version of the draw monoid.\nconst DRAWTAG_NOP = 0u;\nconst DRAWTAG_FILL_COLOR = 0x44u;\nconst DRAWTAG_FILL_LIN_GRADIENT = 0x114u;\nconst DRAWTAG_FILL_RAD_GRADIENT = 0x29cu;\nconst DRAWTAG_FILL_IMAGE = 0x248u;\nconst DRAWTAG_BEGIN_CLIP = 0x9u;\nconst DRAWTAG_END_CLIP = 0x21u;\n\nfn draw_monoid_identity() -> DrawMonoid {\n    return DrawMonoid();\n}\n\nfn combine_draw_monoid(a: DrawMonoid, b: DrawMonoid) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = a.path_ix + b.path_ix;\n    c.clip_ix = a.clip_ix + b.clip_ix;\n    c.scene_offset = a.scene_offset + b.scene_offset;\n    c.info_offset = a.info_offset + b.info_offset;\n    return c;\n}\n\nfn map_draw_tag(tag_word: u32) -> DrawMonoid {\n    var c: DrawMonoid;\n    c.path_ix = u32(tag_word != DRAWTAG_NOP);\n    c.clip_ix = tag_word & 1u;\n    c.scene_offset = (tag_word >> 2u) & 0x07u;\n    c.info_offset = (tag_word >> 6u) & 0x0fu;\n    return c;\n}\n\n// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense\n\n// Common datatypes for path and tile intermediate info.\n\nstruct Path {\n    // bounding box in tiles\n    bbox: vec4<u32>,\n    // offset (in u32's) to tile rectangle\n    tiles: u32,\n}\n\nstruct Tile {\n    backdrop: i32,\n    segments: u32,\n}\n\n\n@group(0) @binding(0)\nvar<uniform> config: Config;\n\n@group(0) @binding(1)\nvar<storage> scene: array<u32>;\n\n@group(0) @binding(2)\nvar<storage> draw_bboxes: array<vec4<f32>>;\n\n@group(0) @binding(3)\nvar<storage, read_write> bump: BumpAllocators;\n\n@group(0) @binding(4)\nvar<storage, read_write> paths: array<Path>;\n\n@group(0) @binding(5)\nvar<storage, read_write> tiles: array<Tile>;\n\nconst WG_SIZE = 256u;\n\nvar<workgroup> sh_tile_count: array<u32, WG_SIZE>;\nvar<workgroup> sh_tile_offset: u32;\n\n@compute @workgroup_size(256)\nfn main(\n    @builtin(global_invocation_id) global_id: vec3<u32>,\n    @builtin(local_invocation_id) local_id: vec3<u32>,\n) {\n    // Exit early if prior stages failed, as we can't run this stage.\n    // We need to check only prior stages, as if this stage has failed in another workgroup, \n    // we still want to know this workgroup's memory requirement.\n    let failed = atomicLoad(&bump.failed);\n    if (failed & STAGE_BINNING) != 0u {\n        return;\n    }    \n    // scale factors useful for converting coordinates to tiles\n    // TODO: make into constants\n    let SX = 1.0 / f32(TILE_WIDTH);\n    let SY = 1.0 / f32(TILE_HEIGHT);\n\n    let drawobj_ix = global_id.x;\n    var drawtag = DRAWTAG_NOP;\n    if drawobj_ix < config.n_drawobj {\n        drawtag = scene[config.drawtag_base + drawobj_ix];\n    }\n    var x0 = 0;\n    var y0 = 0;\n    var x1 = 0;\n    var y1 = 0;\n    if drawtag != DRAWTAG_NOP && drawtag != DRAWTAG_END_CLIP {\n        let bbox = draw_bboxes[drawobj_ix];\n        x0 = i32(floor(bbox.x * SX));\n        y0 = i32(floor(bbox.y * SY));\n        x1 = i32(ceil(bbox.z * SX));\n        y1 = i32(ceil(bbox.w * SY));\n    }\n    let ux0 = u32(clamp(x0, 0, i32(config.width_in_tiles)));\n    let uy0 = u32(clamp(y0, 0, i32(config.height_in_tiles)));\n    let ux1 = u32(clamp(x1, 0, i32(config.width_in_tiles)));\n    let uy1 = u32(clamp(y1, 0, i32(config.height_in_tiles)));\n    let tile_count = (ux1 - ux0) * (uy1 - uy0);\n    var total_tile_count = tile_count;\n    sh_tile_count[local_id.x] = tile_count;\n    for (var i = 0u; i < firstTrailingBit(WG_SIZE); i += 1u) {\n        workgroupBarrier();\n        if local_id.x >= (1u << i) {\n            total_tile_count += sh_tile_count[local_id.x - (1u << i)];\n        }\n        workgroupBarrier();\n        sh_tile_count[local_id.x] = total_tile_count;\n    }\n    if local_id.x == WG_SIZE - 1u {\n        let count = sh_tile_count[WG_SIZE - 1u];\n        var offset = atomicAdd(&bump.tile, count);\n        if offset + count > config.tiles_size {\n            offset = 0u;\n            atomicOr(&bump.failed, STAGE_TILE_ALLOC);\n        }\n        paths[drawobj_ix].tiles = offset;\n    }    \n    // Using storage barriers is a workaround for what appears to be a miscompilation\n    // when a normal workgroup-shared variable is used to broadcast the value.\n    storageBarrier();\n    let tile_offset = paths[drawobj_ix | (WG_SIZE - 1u)].tiles;\n    storageBarrier();\n    if drawobj_ix < config.n_drawobj {\n        let tile_subix = select(0u, sh_tile_count[local_id.x - 1u], local_id.x > 0u);\n        let bbox = vec4(ux0, uy0, ux1, uy1);\n        let path = Path(bbox, tile_offset + tile_subix);\n        paths[drawobj_ix] = path;\n    }\n\n    // zero allocated memory\n    // Note: if the number of draw objects is small, utilization will be poor.\n    // There are two things that can be done to improve that. One would be a\n    // separate (indirect) dispatch. Another would be to have each workgroup\n    // process fewer draw objects than the number of threads in the wg.\n    let total_count = sh_tile_count[WG_SIZE - 1u];\n    for (var i = local_id.x; i < total_count; i += WG_SIZE) {\n        // Note: could format output buffer as u32 for even better load balancing.\n        tiles[tile_offset + i] = Tile(0, 0u);\n    }\n}\n",
    workgroup_size: [ 256, 1, 1 ],
    bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer', 'Buffer' ],
    workgroup_buffers: [
      { size_in_bytes: 1024, index: 0 }
    ]
  }
} );
export default shaders;